/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/main.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/main.js":
/*!*********************!*\
  !*** ./src/main.js ***!
  \*********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _modules_constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./modules/constants.js */ \"./src/modules/constants.js\");\n/* harmony import */ var _modules_utilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./modules/utilities.js */ \"./src/modules/utilities.js\");\n/* harmony import */ var _modules_highlighting_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./modules/highlighting.js */ \"./src/modules/highlighting.js\");\n\n\n\n\n// This step is performed to parse the url to identify the dataset and the default coloring column\nvar query = window.location.search.substring(1);\nvar temp_query = query.split(\"&\");\nvar dicts = {};\nvar tvars, dataset;\nfor(var i=0;i<temp_query.length;i++) {\n  tvars = temp_query[i].split(\"=\");\n  dicts[tvars[0]]=tvars[1].replace(/%20/g, \" \");\n}\nif (\"dataset\" in dicts) {\n  dataset = dicts[\"dataset\"];\n} else {\n  dataset = \"joined_data.csv\";\n}\nvar weights_2darray = [], biases_1darray = [], vocab_1darray = [], vectorspace_2darray = [], bow_2darray = [];\n// Semantic model option set up\nif (\"semantic_model\" in dicts && dicts[\"semantic_model\"] == \"true\") {\n  console.log('Using semantic model.\\nGetting matrices...');\n  var weightsfile = dataset.split(/\\.t[a-z]{2}$/)[0]+'_weights.txt';\n  var biasesfile = dataset.split(/\\.t[a-z]{2}$/)[0]+'_biases.txt';\n  var vocabfile = dataset.split(/\\.t[a-z]{2}$/)[0]+'_vocab.txt';\n  var vectorfile = 'VS-' + dataset.split(\"_semantic\")[0]+'.txt';\n  var bowfile = dataset.split(/\\.t[a-z]{2}$/)[0]+'_bow.txt';\n\n  console.log(\"Reading \" + bowfile);\n  d3.tsv(bowfile, function(text){\n    bow_2darray = text.map( Object.values );\n    bow_2darray = bow_2darray.map(function(entry) {\n      return entry.map(function(elem) {\n        return Math.round(parseFloat(elem));\n      });\n    });\n  });\n  console.log(\"Reading \" + vectorfile);\n  d3.tsv(vectorfile, function(text){\n    vectorspace_2darray = text.map( Object.values );\n    vectorspace_2darray = vectorspace_2darray.map(function(arr) {\n            // username column ends up last in the dictionary, due to alphanumeric sort\n            return arr.slice(0,-1).map(function(elem) {\n              return parseFloat(elem);\n            });\n          });\n  });\n  console.log(\"Reading \" + weightsfile);\n  d3.tsv(weightsfile, function(text){\n    weights_2darray = text.map( Object.values );\n    weights_2darray = weights_2darray.map(function(entry) {\n      return entry.map(function(elem) {\n        return parseFloat(elem);\n      });\n    });\n  });\n  console.log(\"Reading \" + biasesfile);\n  d3.tsv(biasesfile, function(text){\n    biases_1darray = text.map( Object.values );\n    biases_1darray = Object.values(biases_1darray.map(Number));\n  });\n  console.log(\"Reading \" + vocabfile);\n  d3.tsv(vocabfile, function(text){\n    vocab_1darray = text.map( Object.values );\n    vocab_1darray = Object.values(vocab_1darray.map(String));\n  });\n}\n\n// setup fill color\nvar color_column;\n\n// coloring will be done according to the values determined by cValue\n// var cValue = function(d) {return d[color_column];},\nvar cValue2 = function(d) {return Math.log(parseFloat(d[color_column]));},\ncolor = d3.scale.ordinal().range(_modules_constants_js__WEBPACK_IMPORTED_MODULE_0__[\"d3_category20_shuffled\"]);\n\n\n// create the dropdown menu\n// Coloring\nvar dropDown = d3.select(\"body\").append(\"select\")\n.attr(\"class\", \"select1\")\n.attr(\"name\", \"color_column\");\n\n// Searching\nvar dropDown1 = d3.select(\"body\").append(\"select\")\n.attr(\"class\", \"select2\")\n.attr(\"name\", \"color_column\");\n\n// Transparent\nvar dropDown2 = d3.select(\"body\").append(\"select\")\n.attr(\"class\", \"select4\")\n.attr(\"name\", \"color_column\");\n\n// Click on feature\nvar dropDown3 = d3.select(\"body\").append(\"select\")\n.attr(\"class\", \"select5\")\n.attr(\"name\", \"color_column\");\n\n// Shaping\nvar dropDown4 = d3.select(\"body\").append(\"select\")\n.attr(\"class\", \"select6\")\n.attr(\"name\", \"color_column\");\n\nvar categories = [];\n// category_search stores the name of column according to which searching is to be done\nvar category_search_data = [];\n// categories stores the name of all the columns\nvar category_search;\n\ncategories.push(\"Select\");\n// check whether the searching column is provided in the url or not\nif (\"search\" in dicts) {\n  category_search = dicts[\"search\"];\n  category_search_data.push(category_search);\n}\n\n\n// color_column stores the name of column according to which coloring is to be done\n// check whether the coloring column is provided in the url or not\nif (\"color\" in dicts) {\n  color_column = dicts[\"color\"];\n  categories.push(color_column);\n} else {\n  color_column = \"Select\";\n}\n\n// categories_copy_color is just the copy of categories\nvar categories_copy_color = [];\ncategories_copy_color.push(color_column);\n\nvar columns = [], temp = [];\n\n// column for the transparent value\nvar transparent_column = \"Select\", feature_column = \"\", shaping_column = \"Select\";\n\nconsole.log('Loading main data')\n// getting header from csv file to make drowdown menus\nd3.tsv(dataset, function(data) {\n  console.log(data[0]);\n  temp = Object.keys(data[0]);\n    // remove x and y\n    temp.splice(temp.indexOf('x'), 1);\n    temp.splice(temp.indexOf('y'), 1);\n\n    for(var i=0;i<temp.length;i++)\n      if (temp[i] != category_search) {\n        category_search_data.push(temp[i]);\n      }\n\n      for(var i=0;i<temp.length;i++) {\n        // color_column already pushed\n        if (temp[i] != color_column) {\n          categories.push(temp[i]);\n          categories_copy_color.push(temp[i]);\n        }\n        columns.push(temp[i]);\n      }\n    // check whether the coloring column is provided in the url or not\n    // ?? is this necessary? color_column is already defined with the same procedure outside the function\n    if (\"color\" in dicts) {\n      color_column = categories[1]; // since color would be first, start with next\n    } else {\n      // color_column = \"Select\"\n      color_column = categories[0];\n    }\n    category_search = category_search_data[0];\n    // Searching\n    dropDown1.selectAll(\"option\")\n    .data(category_search_data)\n    .enter()\n    .append(\"option\")\n    .text(function(d) { return d;})\n    .text(function(d) {return d;});\n    // Coloring\n    dropDown.selectAll(\"option\")\n    .data(categories_copy_color)\n    .enter()\n    .append(\"option\")\n    .text(function(d) { return d;})\n    .text(function(d) {return d;});\n    // Transparent\n    dropDown2.selectAll(\"option\")\n    .data(category_search_data)\n    .enter()\n    .append(\"option\")\n    .text(function(d) { return d;})\n    .text(function(d) {return d;});\n    // Click on feature\n    dropDown3.selectAll(\"option\")\n    .data(category_search_data)\n    .enter()\n    .append(\"option\")\n    .text(function(d) { return d;})\n    .text(function(d) {return d;});\n    // Shaping\n    dropDown4.selectAll(\"option\")\n    .data(categories)\n    .enter()\n    .append(\"option\")\n    .text(function(d) { return d;})\n    .text(function(d) {return d;});\n    shaping_column = categories[0];\n    feature_column = category_search_data[0];\n    transparent_column = category_search_data[0];\n  });\n\n// whenever any one of the drowdown menu's selected column is changes the plot is generated according to the value of dropdown menu selected\n// Coloring\ndropDown.on(\"change\", plotting);\n// Searching\ndropDown1.on(\"change\", plotting2);\n// Transparent\ndropDown2.on(\"change\", plotting3);\n// Click on feature\ndropDown3.on(\"change\", plotting4);\n// Shaping\ndropDown4.on(\"change\", plotting5);\n\nif (\"q\" in dicts) {\n  Object(_modules_highlighting_js__WEBPACK_IMPORTED_MODULE_2__[\"highlighting\"])(dicts, dataset, categories, shaping_column, columns, category_search, category_search_data, feature_column, color_column, color, zoomed, needZoom, transparent_column, dicts[\"q\"], \"\", \"\");\n} else {\n  Object(_modules_highlighting_js__WEBPACK_IMPORTED_MODULE_2__[\"highlighting\"])(dicts, dataset, categories, shaping_column, columns, category_search, category_search_data, feature_column, color_column, color, zoomed, needZoom, transparent_column, \"\", \"\", \"\");\n}\n\n// the functions to call when the value of dropdown menu is changes\n// Click on feature\nfunction plotting4(){\n  feature_column = d3.event.target.value;\n}\n// Transparent\nfunction plotting3(){\n  transparent_column = d3.event.target.value;\n}\n// Searching\nfunction plotting2(){\n  category_search = d3.event.target.value;\n}\n\n// function to call for change event\n// Coloring\nfunction plotting(){\n  color_column = d3.event.target.value;\n  cValue = function(d) { return d[color_column];};\n  val_opacityMatch = document.getElementById(\"opacityMatch\").value;\n  val_opacityNoMatch = document.getElementById(\"opacityNoMatch\").value;\n  Object(_modules_highlighting_js__WEBPACK_IMPORTED_MODULE_2__[\"highlighting\"])(dicts, dataset, categories, shaping_column, columns, category_search, category_search_data, feature_column, color_column, color, zoomed, needZoom, transparent_column, val_opacityMatch, val_opacityNoMatch);\n}\n\n// function to call for change event\n// Shaping\nfunction plotting5(){\n  shaping_column = d3.event.target.value;\n  cValue = function(d) { return d[color_column];};\n  val_opacityMatch = document.getElementById(\"opacityMatch\").value;\n  val_opacityNoMatch = document.getElementById(\"opacityNoMatch\").value;\n  Object(_modules_highlighting_js__WEBPACK_IMPORTED_MODULE_2__[\"highlighting\"])(dicts, dataset, categories, shaping_column, columns, category_search, category_search_data, feature_column, color_column, color, zoomed, needZoom, transparent_column, val_opacityMatch, val_opacityNoMatch);\n}\n\nvar zoomed = 0;\nvar needZoom = false;\nvar needDrawCircle = false;\n\n// search event\n// it will be executed when search button is pressed and points that matches the searched string will be highlighted\nfunction handleClick(event) {\n  console.log(document.getElementById(\"searchText\").value);\n  val_opacityMatch = document.getElementById(\"opacityMatch\").value;\n  val_opacityNoMatch = document.getElementById(\"opacityNoMatch\").value;\n  Object(_modules_highlighting_js__WEBPACK_IMPORTED_MODULE_2__[\"highlighting\"])(dicts, dataset, categories, shaping_column, columns, category_search, category_search_data, feature_column, color_column, color, zoomed, needZoom, transparent_column, val_opacityMatch, val_opacityNoMatch);\n  return false;\n}\nfunction handleCheck(event) {\n  if (document.getElementById(\"searchText\").value) {\n    handleClick();\n  }\n}\n\n// transparent event\n// it will be executed when Transparent button is pressed and points that satisfies the condition will be highlighted\nfunction handleClick1(event) {\n  console.log(document.getElementById(\"transpText\").value);\n  val_opacityMatch = document.getElementById(\"opacityMatch\").value;\n  val_opacityNoMatch = document.getElementById(\"opacityNoMatch\").value;\n  Object(_modules_highlighting_js__WEBPACK_IMPORTED_MODULE_2__[\"highlighting\"])(dicts, dataset, categories, shaping_column, columns, category_search, category_search_data, feature_column, color_column, color, zoomed, needZoom, transparent_column, val_opacityMatch, val_opacityNoMatch);\n  return false;\n}\nfunction handleCheck1(event) {\n  if (document.getElementById(\"transpText\").value) {\n    handleClick1();\n  }\n}\n\n// ?? I believe this function is unused, and draw also maps to handleClick4\n// it will be executed when Draw button is pressed and the plot will highlight those points that covers fixed percentage of point from the point obtained by mouse click\nfunction handleClick2(event){\n  shaping_column = \"Select\";\n  color_column = \"Select\";\n  myForm.searchText.value = 0;\n  myForm1.transpText.value = 0;\n  myForm1.opacityMatch.value = 0;\n  myForm1.opacityNoMatch.value = 0;\n  dropDown4.property( \"value\", \"Select\" );\n  dropDown.property( \"value\", \"Select\" );\n  Object(_modules_highlighting_js__WEBPACK_IMPORTED_MODULE_2__[\"highlighting\"])(dicts, dataset, categories, shaping_column, columns, category_search, category_search_data, feature_column, color_column, color, zoomed, needZoom, transparent_column, \"\", \"\", \"\");\n  return false;\n}\n\n// spectrum / log event\n// it will be executed when spectrum/log is checked\n// ?? Can we collapse handleClick1,3,4?\nfunction handleClick3(event) {\n  val_opacityMatch = document.getElementById(\"opacityMatch\").value;\n  val_opacityNoMatch = document.getElementById(\"opacityNoMatch\").value;\n  Object(_modules_highlighting_js__WEBPACK_IMPORTED_MODULE_2__[\"highlighting\"])(dicts, dataset, categories, shaping_column, columns, category_search, category_search_data, feature_column, color_column, color, zoomed, needZoom, transparent_column, val_opacityMatch, val_opacityNoMatch);\n}\n\n// it will be executed when (?? draw and) zoom button is pressed and the plot will zoomed out according to the points obtained by mouse click event\nfunction handleClick4(){\n  if (!document.getElementById('cbox3').checked) {\n      document.getElementById(\"zoomxy\").value = \"\"; // clear the textbox\n    }\n\n    val_opacityMatch = document.getElementById(\"opacityMatch\").value;\n    val_opacityNoMatch = document.getElementById(\"opacityNoMatch\").value;\n    needZoom = true;\n    Object(_modules_highlighting_js__WEBPACK_IMPORTED_MODULE_2__[\"highlighting\"])(dicts, dataset, categories, shaping_column, columns, category_search, category_search_data, feature_column, color_column, color, zoomed, needZoom, transparent_column, val_opacityMatch, val_opacityNoMatch);\n  }\n\n\nfunction linspace(start, end, n) {\n  var out = [];\n  var delta = (end - start) / (n - 1);\n  var i = 0;\n  while(i < (n - 1)) {\n    out.push(start + (i * delta));\n    i++;\n  }\n  out.push(end);\n  return out;\n}\n\n// provides different colored spectrum\nvar scale_d = {\n  'puOr11': ['#7f3b08', '#b35806', '#e08214', '#fdb863', '#fee0b6', '#f7f7f7', '#d8daeb', '#b2abd2', '#8073ac', '#542788', '#2d004b'],\n  'spectral8': ['#d53e4f', '#f46d43', '#fdae61', '#fee08b', '#e6f598', '#abdda4', '#66c2a5', '#3288bd'],\n  'redBlackGreen': ['#ff0000', '#AA0000', '#550000', '#005500', '#00AA00', '#00ff00'],\n};\nlet scale = scale_d['spectral8'];\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbWFpbi5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9tYWluLmpzPzU2ZDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgd2lkdGgsIGhlaWdodCwgZDNfY2F0ZWdvcnkyMF9zaHVmZmxlZCB9IGZyb20gJy4vbW9kdWxlcy9jb25zdGFudHMuanMnO1xuaW1wb3J0IHsgXG4gIHhWYWx1ZSxcbiAgeVZhbHVlLFxuICB4U2NhbGUsXG4gIHlTY2FsZSxcbiAgeE1hcCxcbiAgeU1hcCxcbiAgeEF4aXMsXG4gIHlBeGlzIFxufSBmcm9tICcuL21vZHVsZXMvdXRpbGl0aWVzLmpzJztcbmltcG9ydCB7IGhpZ2hsaWdodGluZyB9IGZyb20gJy4vbW9kdWxlcy9oaWdobGlnaHRpbmcuanMnO1xuXG4vLyBUaGlzIHN0ZXAgaXMgcGVyZm9ybWVkIHRvIHBhcnNlIHRoZSB1cmwgdG8gaWRlbnRpZnkgdGhlIGRhdGFzZXQgYW5kIHRoZSBkZWZhdWx0IGNvbG9yaW5nIGNvbHVtblxudmFyIHF1ZXJ5ID0gd2luZG93LmxvY2F0aW9uLnNlYXJjaC5zdWJzdHJpbmcoMSk7XG52YXIgdGVtcF9xdWVyeSA9IHF1ZXJ5LnNwbGl0KFwiJlwiKTtcbnZhciBkaWN0cyA9IHt9O1xudmFyIHR2YXJzLCBkYXRhc2V0O1xuZm9yKHZhciBpPTA7aTx0ZW1wX3F1ZXJ5Lmxlbmd0aDtpKyspIHtcbiAgdHZhcnMgPSB0ZW1wX3F1ZXJ5W2ldLnNwbGl0KFwiPVwiKTtcbiAgZGljdHNbdHZhcnNbMF1dPXR2YXJzWzFdLnJlcGxhY2UoLyUyMC9nLCBcIiBcIik7XG59XG5pZiAoXCJkYXRhc2V0XCIgaW4gZGljdHMpIHtcbiAgZGF0YXNldCA9IGRpY3RzW1wiZGF0YXNldFwiXTtcbn0gZWxzZSB7XG4gIGRhdGFzZXQgPSBcImpvaW5lZF9kYXRhLmNzdlwiO1xufVxudmFyIHdlaWdodHNfMmRhcnJheSA9IFtdLCBiaWFzZXNfMWRhcnJheSA9IFtdLCB2b2NhYl8xZGFycmF5ID0gW10sIHZlY3RvcnNwYWNlXzJkYXJyYXkgPSBbXSwgYm93XzJkYXJyYXkgPSBbXTtcbi8vIFNlbWFudGljIG1vZGVsIG9wdGlvbiBzZXQgdXBcbmlmIChcInNlbWFudGljX21vZGVsXCIgaW4gZGljdHMgJiYgZGljdHNbXCJzZW1hbnRpY19tb2RlbFwiXSA9PSBcInRydWVcIikge1xuICBjb25zb2xlLmxvZygnVXNpbmcgc2VtYW50aWMgbW9kZWwuXFxuR2V0dGluZyBtYXRyaWNlcy4uLicpO1xuICB2YXIgd2VpZ2h0c2ZpbGUgPSBkYXRhc2V0LnNwbGl0KC9cXC50W2Etel17Mn0kLylbMF0rJ193ZWlnaHRzLnR4dCc7XG4gIHZhciBiaWFzZXNmaWxlID0gZGF0YXNldC5zcGxpdCgvXFwudFthLXpdezJ9JC8pWzBdKydfYmlhc2VzLnR4dCc7XG4gIHZhciB2b2NhYmZpbGUgPSBkYXRhc2V0LnNwbGl0KC9cXC50W2Etel17Mn0kLylbMF0rJ192b2NhYi50eHQnO1xuICB2YXIgdmVjdG9yZmlsZSA9ICdWUy0nICsgZGF0YXNldC5zcGxpdChcIl9zZW1hbnRpY1wiKVswXSsnLnR4dCc7XG4gIHZhciBib3dmaWxlID0gZGF0YXNldC5zcGxpdCgvXFwudFthLXpdezJ9JC8pWzBdKydfYm93LnR4dCc7XG5cbiAgY29uc29sZS5sb2coXCJSZWFkaW5nIFwiICsgYm93ZmlsZSk7XG4gIGQzLnRzdihib3dmaWxlLCBmdW5jdGlvbih0ZXh0KXtcbiAgICBib3dfMmRhcnJheSA9IHRleHQubWFwKCBPYmplY3QudmFsdWVzICk7XG4gICAgYm93XzJkYXJyYXkgPSBib3dfMmRhcnJheS5tYXAoZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgIHJldHVybiBlbnRyeS5tYXAoZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICByZXR1cm4gTWF0aC5yb3VuZChwYXJzZUZsb2F0KGVsZW0pKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgY29uc29sZS5sb2coXCJSZWFkaW5nIFwiICsgdmVjdG9yZmlsZSk7XG4gIGQzLnRzdih2ZWN0b3JmaWxlLCBmdW5jdGlvbih0ZXh0KXtcbiAgICB2ZWN0b3JzcGFjZV8yZGFycmF5ID0gdGV4dC5tYXAoIE9iamVjdC52YWx1ZXMgKTtcbiAgICB2ZWN0b3JzcGFjZV8yZGFycmF5ID0gdmVjdG9yc3BhY2VfMmRhcnJheS5tYXAoZnVuY3Rpb24oYXJyKSB7XG4gICAgICAgICAgICAvLyB1c2VybmFtZSBjb2x1bW4gZW5kcyB1cCBsYXN0IGluIHRoZSBkaWN0aW9uYXJ5LCBkdWUgdG8gYWxwaGFudW1lcmljIHNvcnRcbiAgICAgICAgICAgIHJldHVybiBhcnIuc2xpY2UoMCwtMSkubWFwKGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoZWxlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgfSk7XG4gIGNvbnNvbGUubG9nKFwiUmVhZGluZyBcIiArIHdlaWdodHNmaWxlKTtcbiAgZDMudHN2KHdlaWdodHNmaWxlLCBmdW5jdGlvbih0ZXh0KXtcbiAgICB3ZWlnaHRzXzJkYXJyYXkgPSB0ZXh0Lm1hcCggT2JqZWN0LnZhbHVlcyApO1xuICAgIHdlaWdodHNfMmRhcnJheSA9IHdlaWdodHNfMmRhcnJheS5tYXAoZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgIHJldHVybiBlbnRyeS5tYXAoZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChlbGVtKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbiAgY29uc29sZS5sb2coXCJSZWFkaW5nIFwiICsgYmlhc2VzZmlsZSk7XG4gIGQzLnRzdihiaWFzZXNmaWxlLCBmdW5jdGlvbih0ZXh0KXtcbiAgICBiaWFzZXNfMWRhcnJheSA9IHRleHQubWFwKCBPYmplY3QudmFsdWVzICk7XG4gICAgYmlhc2VzXzFkYXJyYXkgPSBPYmplY3QudmFsdWVzKGJpYXNlc18xZGFycmF5Lm1hcChOdW1iZXIpKTtcbiAgfSk7XG4gIGNvbnNvbGUubG9nKFwiUmVhZGluZyBcIiArIHZvY2FiZmlsZSk7XG4gIGQzLnRzdih2b2NhYmZpbGUsIGZ1bmN0aW9uKHRleHQpe1xuICAgIHZvY2FiXzFkYXJyYXkgPSB0ZXh0Lm1hcCggT2JqZWN0LnZhbHVlcyApO1xuICAgIHZvY2FiXzFkYXJyYXkgPSBPYmplY3QudmFsdWVzKHZvY2FiXzFkYXJyYXkubWFwKFN0cmluZykpO1xuICB9KTtcbn1cblxuLy8gc2V0dXAgZmlsbCBjb2xvclxudmFyIGNvbG9yX2NvbHVtbjtcblxuLy8gY29sb3Jpbmcgd2lsbCBiZSBkb25lIGFjY29yZGluZyB0byB0aGUgdmFsdWVzIGRldGVybWluZWQgYnkgY1ZhbHVlXG4vLyB2YXIgY1ZhbHVlID0gZnVuY3Rpb24oZCkge3JldHVybiBkW2NvbG9yX2NvbHVtbl07fSxcbnZhciBjVmFsdWUyID0gZnVuY3Rpb24oZCkge3JldHVybiBNYXRoLmxvZyhwYXJzZUZsb2F0KGRbY29sb3JfY29sdW1uXSkpO30sXG5jb2xvciA9IGQzLnNjYWxlLm9yZGluYWwoKS5yYW5nZShkM19jYXRlZ29yeTIwX3NodWZmbGVkKTtcblxuXG4vLyBjcmVhdGUgdGhlIGRyb3Bkb3duIG1lbnVcbi8vIENvbG9yaW5nXG52YXIgZHJvcERvd24gPSBkMy5zZWxlY3QoXCJib2R5XCIpLmFwcGVuZChcInNlbGVjdFwiKVxuLmF0dHIoXCJjbGFzc1wiLCBcInNlbGVjdDFcIilcbi5hdHRyKFwibmFtZVwiLCBcImNvbG9yX2NvbHVtblwiKTtcblxuLy8gU2VhcmNoaW5nXG52YXIgZHJvcERvd24xID0gZDMuc2VsZWN0KFwiYm9keVwiKS5hcHBlbmQoXCJzZWxlY3RcIilcbi5hdHRyKFwiY2xhc3NcIiwgXCJzZWxlY3QyXCIpXG4uYXR0cihcIm5hbWVcIiwgXCJjb2xvcl9jb2x1bW5cIik7XG5cbi8vIFRyYW5zcGFyZW50XG52YXIgZHJvcERvd24yID0gZDMuc2VsZWN0KFwiYm9keVwiKS5hcHBlbmQoXCJzZWxlY3RcIilcbi5hdHRyKFwiY2xhc3NcIiwgXCJzZWxlY3Q0XCIpXG4uYXR0cihcIm5hbWVcIiwgXCJjb2xvcl9jb2x1bW5cIik7XG5cbi8vIENsaWNrIG9uIGZlYXR1cmVcbnZhciBkcm9wRG93bjMgPSBkMy5zZWxlY3QoXCJib2R5XCIpLmFwcGVuZChcInNlbGVjdFwiKVxuLmF0dHIoXCJjbGFzc1wiLCBcInNlbGVjdDVcIilcbi5hdHRyKFwibmFtZVwiLCBcImNvbG9yX2NvbHVtblwiKTtcblxuLy8gU2hhcGluZ1xudmFyIGRyb3BEb3duNCA9IGQzLnNlbGVjdChcImJvZHlcIikuYXBwZW5kKFwic2VsZWN0XCIpXG4uYXR0cihcImNsYXNzXCIsIFwic2VsZWN0NlwiKVxuLmF0dHIoXCJuYW1lXCIsIFwiY29sb3JfY29sdW1uXCIpO1xuXG52YXIgY2F0ZWdvcmllcyA9IFtdO1xuLy8gY2F0ZWdvcnlfc2VhcmNoIHN0b3JlcyB0aGUgbmFtZSBvZiBjb2x1bW4gYWNjb3JkaW5nIHRvIHdoaWNoIHNlYXJjaGluZyBpcyB0byBiZSBkb25lXG52YXIgY2F0ZWdvcnlfc2VhcmNoX2RhdGEgPSBbXTtcbi8vIGNhdGVnb3JpZXMgc3RvcmVzIHRoZSBuYW1lIG9mIGFsbCB0aGUgY29sdW1uc1xudmFyIGNhdGVnb3J5X3NlYXJjaDtcblxuY2F0ZWdvcmllcy5wdXNoKFwiU2VsZWN0XCIpO1xuLy8gY2hlY2sgd2hldGhlciB0aGUgc2VhcmNoaW5nIGNvbHVtbiBpcyBwcm92aWRlZCBpbiB0aGUgdXJsIG9yIG5vdFxuaWYgKFwic2VhcmNoXCIgaW4gZGljdHMpIHtcbiAgY2F0ZWdvcnlfc2VhcmNoID0gZGljdHNbXCJzZWFyY2hcIl07XG4gIGNhdGVnb3J5X3NlYXJjaF9kYXRhLnB1c2goY2F0ZWdvcnlfc2VhcmNoKTtcbn1cblxuXG4vLyBjb2xvcl9jb2x1bW4gc3RvcmVzIHRoZSBuYW1lIG9mIGNvbHVtbiBhY2NvcmRpbmcgdG8gd2hpY2ggY29sb3JpbmcgaXMgdG8gYmUgZG9uZVxuLy8gY2hlY2sgd2hldGhlciB0aGUgY29sb3JpbmcgY29sdW1uIGlzIHByb3ZpZGVkIGluIHRoZSB1cmwgb3Igbm90XG5pZiAoXCJjb2xvclwiIGluIGRpY3RzKSB7XG4gIGNvbG9yX2NvbHVtbiA9IGRpY3RzW1wiY29sb3JcIl07XG4gIGNhdGVnb3JpZXMucHVzaChjb2xvcl9jb2x1bW4pO1xufSBlbHNlIHtcbiAgY29sb3JfY29sdW1uID0gXCJTZWxlY3RcIjtcbn1cblxuLy8gY2F0ZWdvcmllc19jb3B5X2NvbG9yIGlzIGp1c3QgdGhlIGNvcHkgb2YgY2F0ZWdvcmllc1xudmFyIGNhdGVnb3JpZXNfY29weV9jb2xvciA9IFtdO1xuY2F0ZWdvcmllc19jb3B5X2NvbG9yLnB1c2goY29sb3JfY29sdW1uKTtcblxudmFyIGNvbHVtbnMgPSBbXSwgdGVtcCA9IFtdO1xuXG4vLyBjb2x1bW4gZm9yIHRoZSB0cmFuc3BhcmVudCB2YWx1ZVxudmFyIHRyYW5zcGFyZW50X2NvbHVtbiA9IFwiU2VsZWN0XCIsIGZlYXR1cmVfY29sdW1uID0gXCJcIiwgc2hhcGluZ19jb2x1bW4gPSBcIlNlbGVjdFwiO1xuXG5jb25zb2xlLmxvZygnTG9hZGluZyBtYWluIGRhdGEnKVxuLy8gZ2V0dGluZyBoZWFkZXIgZnJvbSBjc3YgZmlsZSB0byBtYWtlIGRyb3dkb3duIG1lbnVzXG5kMy50c3YoZGF0YXNldCwgZnVuY3Rpb24oZGF0YSkge1xuICBjb25zb2xlLmxvZyhkYXRhWzBdKTtcbiAgdGVtcCA9IE9iamVjdC5rZXlzKGRhdGFbMF0pO1xuICAgIC8vIHJlbW92ZSB4IGFuZCB5XG4gICAgdGVtcC5zcGxpY2UodGVtcC5pbmRleE9mKCd4JyksIDEpO1xuICAgIHRlbXAuc3BsaWNlKHRlbXAuaW5kZXhPZigneScpLCAxKTtcblxuICAgIGZvcih2YXIgaT0wO2k8dGVtcC5sZW5ndGg7aSsrKVxuICAgICAgaWYgKHRlbXBbaV0gIT0gY2F0ZWdvcnlfc2VhcmNoKSB7XG4gICAgICAgIGNhdGVnb3J5X3NlYXJjaF9kYXRhLnB1c2godGVtcFtpXSk7XG4gICAgICB9XG5cbiAgICAgIGZvcih2YXIgaT0wO2k8dGVtcC5sZW5ndGg7aSsrKSB7XG4gICAgICAgIC8vIGNvbG9yX2NvbHVtbiBhbHJlYWR5IHB1c2hlZFxuICAgICAgICBpZiAodGVtcFtpXSAhPSBjb2xvcl9jb2x1bW4pIHtcbiAgICAgICAgICBjYXRlZ29yaWVzLnB1c2godGVtcFtpXSk7XG4gICAgICAgICAgY2F0ZWdvcmllc19jb3B5X2NvbG9yLnB1c2godGVtcFtpXSk7XG4gICAgICAgIH1cbiAgICAgICAgY29sdW1ucy5wdXNoKHRlbXBbaV0pO1xuICAgICAgfVxuICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhlIGNvbG9yaW5nIGNvbHVtbiBpcyBwcm92aWRlZCBpbiB0aGUgdXJsIG9yIG5vdFxuICAgIC8vID8/IGlzIHRoaXMgbmVjZXNzYXJ5PyBjb2xvcl9jb2x1bW4gaXMgYWxyZWFkeSBkZWZpbmVkIHdpdGggdGhlIHNhbWUgcHJvY2VkdXJlIG91dHNpZGUgdGhlIGZ1bmN0aW9uXG4gICAgaWYgKFwiY29sb3JcIiBpbiBkaWN0cykge1xuICAgICAgY29sb3JfY29sdW1uID0gY2F0ZWdvcmllc1sxXTsgLy8gc2luY2UgY29sb3Igd291bGQgYmUgZmlyc3QsIHN0YXJ0IHdpdGggbmV4dFxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBjb2xvcl9jb2x1bW4gPSBcIlNlbGVjdFwiXG4gICAgICBjb2xvcl9jb2x1bW4gPSBjYXRlZ29yaWVzWzBdO1xuICAgIH1cbiAgICBjYXRlZ29yeV9zZWFyY2ggPSBjYXRlZ29yeV9zZWFyY2hfZGF0YVswXTtcbiAgICAvLyBTZWFyY2hpbmdcbiAgICBkcm9wRG93bjEuc2VsZWN0QWxsKFwib3B0aW9uXCIpXG4gICAgLmRhdGEoY2F0ZWdvcnlfc2VhcmNoX2RhdGEpXG4gICAgLmVudGVyKClcbiAgICAuYXBwZW5kKFwib3B0aW9uXCIpXG4gICAgLnRleHQoZnVuY3Rpb24oZCkgeyByZXR1cm4gZDt9KVxuICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHtyZXR1cm4gZDt9KTtcbiAgICAvLyBDb2xvcmluZ1xuICAgIGRyb3BEb3duLnNlbGVjdEFsbChcIm9wdGlvblwiKVxuICAgIC5kYXRhKGNhdGVnb3JpZXNfY29weV9jb2xvcilcbiAgICAuZW50ZXIoKVxuICAgIC5hcHBlbmQoXCJvcHRpb25cIilcbiAgICAudGV4dChmdW5jdGlvbihkKSB7IHJldHVybiBkO30pXG4gICAgLnRleHQoZnVuY3Rpb24oZCkge3JldHVybiBkO30pO1xuICAgIC8vIFRyYW5zcGFyZW50XG4gICAgZHJvcERvd24yLnNlbGVjdEFsbChcIm9wdGlvblwiKVxuICAgIC5kYXRhKGNhdGVnb3J5X3NlYXJjaF9kYXRhKVxuICAgIC5lbnRlcigpXG4gICAgLmFwcGVuZChcIm9wdGlvblwiKVxuICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQ7fSlcbiAgICAudGV4dChmdW5jdGlvbihkKSB7cmV0dXJuIGQ7fSk7XG4gICAgLy8gQ2xpY2sgb24gZmVhdHVyZVxuICAgIGRyb3BEb3duMy5zZWxlY3RBbGwoXCJvcHRpb25cIilcbiAgICAuZGF0YShjYXRlZ29yeV9zZWFyY2hfZGF0YSlcbiAgICAuZW50ZXIoKVxuICAgIC5hcHBlbmQoXCJvcHRpb25cIilcbiAgICAudGV4dChmdW5jdGlvbihkKSB7IHJldHVybiBkO30pXG4gICAgLnRleHQoZnVuY3Rpb24oZCkge3JldHVybiBkO30pO1xuICAgIC8vIFNoYXBpbmdcbiAgICBkcm9wRG93bjQuc2VsZWN0QWxsKFwib3B0aW9uXCIpXG4gICAgLmRhdGEoY2F0ZWdvcmllcylcbiAgICAuZW50ZXIoKVxuICAgIC5hcHBlbmQoXCJvcHRpb25cIilcbiAgICAudGV4dChmdW5jdGlvbihkKSB7IHJldHVybiBkO30pXG4gICAgLnRleHQoZnVuY3Rpb24oZCkge3JldHVybiBkO30pO1xuICAgIHNoYXBpbmdfY29sdW1uID0gY2F0ZWdvcmllc1swXTtcbiAgICBmZWF0dXJlX2NvbHVtbiA9IGNhdGVnb3J5X3NlYXJjaF9kYXRhWzBdO1xuICAgIHRyYW5zcGFyZW50X2NvbHVtbiA9IGNhdGVnb3J5X3NlYXJjaF9kYXRhWzBdO1xuICB9KTtcblxuLy8gd2hlbmV2ZXIgYW55IG9uZSBvZiB0aGUgZHJvd2Rvd24gbWVudSdzIHNlbGVjdGVkIGNvbHVtbiBpcyBjaGFuZ2VzIHRoZSBwbG90IGlzIGdlbmVyYXRlZCBhY2NvcmRpbmcgdG8gdGhlIHZhbHVlIG9mIGRyb3Bkb3duIG1lbnUgc2VsZWN0ZWRcbi8vIENvbG9yaW5nXG5kcm9wRG93bi5vbihcImNoYW5nZVwiLCBwbG90dGluZyk7XG4vLyBTZWFyY2hpbmdcbmRyb3BEb3duMS5vbihcImNoYW5nZVwiLCBwbG90dGluZzIpO1xuLy8gVHJhbnNwYXJlbnRcbmRyb3BEb3duMi5vbihcImNoYW5nZVwiLCBwbG90dGluZzMpO1xuLy8gQ2xpY2sgb24gZmVhdHVyZVxuZHJvcERvd24zLm9uKFwiY2hhbmdlXCIsIHBsb3R0aW5nNCk7XG4vLyBTaGFwaW5nXG5kcm9wRG93bjQub24oXCJjaGFuZ2VcIiwgcGxvdHRpbmc1KTtcblxuaWYgKFwicVwiIGluIGRpY3RzKSB7XG4gIGhpZ2hsaWdodGluZyhkaWN0cywgZGF0YXNldCwgY2F0ZWdvcmllcywgc2hhcGluZ19jb2x1bW4sIGNvbHVtbnMsIGNhdGVnb3J5X3NlYXJjaCwgY2F0ZWdvcnlfc2VhcmNoX2RhdGEsIGZlYXR1cmVfY29sdW1uLCBjb2xvcl9jb2x1bW4sIGNvbG9yLCB6b29tZWQsIG5lZWRab29tLCB0cmFuc3BhcmVudF9jb2x1bW4sIGRpY3RzW1wicVwiXSwgXCJcIiwgXCJcIik7XG59IGVsc2Uge1xuICBoaWdobGlnaHRpbmcoZGljdHMsIGRhdGFzZXQsIGNhdGVnb3JpZXMsIHNoYXBpbmdfY29sdW1uLCBjb2x1bW5zLCBjYXRlZ29yeV9zZWFyY2gsIGNhdGVnb3J5X3NlYXJjaF9kYXRhLCBmZWF0dXJlX2NvbHVtbiwgY29sb3JfY29sdW1uLCBjb2xvciwgem9vbWVkLCBuZWVkWm9vbSwgdHJhbnNwYXJlbnRfY29sdW1uLCBcIlwiLCBcIlwiLCBcIlwiKTtcbn1cblxuLy8gdGhlIGZ1bmN0aW9ucyB0byBjYWxsIHdoZW4gdGhlIHZhbHVlIG9mIGRyb3Bkb3duIG1lbnUgaXMgY2hhbmdlc1xuLy8gQ2xpY2sgb24gZmVhdHVyZVxuZnVuY3Rpb24gcGxvdHRpbmc0KCl7XG4gIGZlYXR1cmVfY29sdW1uID0gZDMuZXZlbnQudGFyZ2V0LnZhbHVlO1xufVxuLy8gVHJhbnNwYXJlbnRcbmZ1bmN0aW9uIHBsb3R0aW5nMygpe1xuICB0cmFuc3BhcmVudF9jb2x1bW4gPSBkMy5ldmVudC50YXJnZXQudmFsdWU7XG59XG4vLyBTZWFyY2hpbmdcbmZ1bmN0aW9uIHBsb3R0aW5nMigpe1xuICBjYXRlZ29yeV9zZWFyY2ggPSBkMy5ldmVudC50YXJnZXQudmFsdWU7XG59XG5cbi8vIGZ1bmN0aW9uIHRvIGNhbGwgZm9yIGNoYW5nZSBldmVudFxuLy8gQ29sb3JpbmdcbmZ1bmN0aW9uIHBsb3R0aW5nKCl7XG4gIGNvbG9yX2NvbHVtbiA9IGQzLmV2ZW50LnRhcmdldC52YWx1ZTtcbiAgY1ZhbHVlID0gZnVuY3Rpb24oZCkgeyByZXR1cm4gZFtjb2xvcl9jb2x1bW5dO307XG4gIHZhbF9vcGFjaXR5TWF0Y2ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm9wYWNpdHlNYXRjaFwiKS52YWx1ZTtcbiAgdmFsX29wYWNpdHlOb01hdGNoID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJvcGFjaXR5Tm9NYXRjaFwiKS52YWx1ZTtcbiAgaGlnaGxpZ2h0aW5nKGRpY3RzLCBkYXRhc2V0LCBjYXRlZ29yaWVzLCBzaGFwaW5nX2NvbHVtbiwgY29sdW1ucywgY2F0ZWdvcnlfc2VhcmNoLCBjYXRlZ29yeV9zZWFyY2hfZGF0YSwgZmVhdHVyZV9jb2x1bW4sIGNvbG9yX2NvbHVtbiwgY29sb3IsIHpvb21lZCwgbmVlZFpvb20sIHRyYW5zcGFyZW50X2NvbHVtbiwgdmFsX29wYWNpdHlNYXRjaCwgdmFsX29wYWNpdHlOb01hdGNoKTtcbn1cblxuLy8gZnVuY3Rpb24gdG8gY2FsbCBmb3IgY2hhbmdlIGV2ZW50XG4vLyBTaGFwaW5nXG5mdW5jdGlvbiBwbG90dGluZzUoKXtcbiAgc2hhcGluZ19jb2x1bW4gPSBkMy5ldmVudC50YXJnZXQudmFsdWU7XG4gIGNWYWx1ZSA9IGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRbY29sb3JfY29sdW1uXTt9O1xuICB2YWxfb3BhY2l0eU1hdGNoID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJvcGFjaXR5TWF0Y2hcIikudmFsdWU7XG4gIHZhbF9vcGFjaXR5Tm9NYXRjaCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwib3BhY2l0eU5vTWF0Y2hcIikudmFsdWU7XG4gIGhpZ2hsaWdodGluZyhkaWN0cywgZGF0YXNldCwgY2F0ZWdvcmllcywgc2hhcGluZ19jb2x1bW4sIGNvbHVtbnMsIGNhdGVnb3J5X3NlYXJjaCwgY2F0ZWdvcnlfc2VhcmNoX2RhdGEsIGZlYXR1cmVfY29sdW1uLCBjb2xvcl9jb2x1bW4sIGNvbG9yLCB6b29tZWQsIG5lZWRab29tLCB0cmFuc3BhcmVudF9jb2x1bW4sIHZhbF9vcGFjaXR5TWF0Y2gsIHZhbF9vcGFjaXR5Tm9NYXRjaCk7XG59XG5cbnZhciB6b29tZWQgPSAwO1xudmFyIG5lZWRab29tID0gZmFsc2U7XG52YXIgbmVlZERyYXdDaXJjbGUgPSBmYWxzZTtcblxuLy8gc2VhcmNoIGV2ZW50XG4vLyBpdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gc2VhcmNoIGJ1dHRvbiBpcyBwcmVzc2VkIGFuZCBwb2ludHMgdGhhdCBtYXRjaGVzIHRoZSBzZWFyY2hlZCBzdHJpbmcgd2lsbCBiZSBoaWdobGlnaHRlZFxuZnVuY3Rpb24gaGFuZGxlQ2xpY2soZXZlbnQpIHtcbiAgY29uc29sZS5sb2coZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzZWFyY2hUZXh0XCIpLnZhbHVlKTtcbiAgdmFsX29wYWNpdHlNYXRjaCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwib3BhY2l0eU1hdGNoXCIpLnZhbHVlO1xuICB2YWxfb3BhY2l0eU5vTWF0Y2ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm9wYWNpdHlOb01hdGNoXCIpLnZhbHVlO1xuICBoaWdobGlnaHRpbmcoZGljdHMsIGRhdGFzZXQsIGNhdGVnb3JpZXMsIHNoYXBpbmdfY29sdW1uLCBjb2x1bW5zLCBjYXRlZ29yeV9zZWFyY2gsIGNhdGVnb3J5X3NlYXJjaF9kYXRhLCBmZWF0dXJlX2NvbHVtbiwgY29sb3JfY29sdW1uLCBjb2xvciwgem9vbWVkLCBuZWVkWm9vbSwgdHJhbnNwYXJlbnRfY29sdW1uLCB2YWxfb3BhY2l0eU1hdGNoLCB2YWxfb3BhY2l0eU5vTWF0Y2gpO1xuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBoYW5kbGVDaGVjayhldmVudCkge1xuICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJzZWFyY2hUZXh0XCIpLnZhbHVlKSB7XG4gICAgaGFuZGxlQ2xpY2soKTtcbiAgfVxufVxuXG4vLyB0cmFuc3BhcmVudCBldmVudFxuLy8gaXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIFRyYW5zcGFyZW50IGJ1dHRvbiBpcyBwcmVzc2VkIGFuZCBwb2ludHMgdGhhdCBzYXRpc2ZpZXMgdGhlIGNvbmRpdGlvbiB3aWxsIGJlIGhpZ2hsaWdodGVkXG5mdW5jdGlvbiBoYW5kbGVDbGljazEoZXZlbnQpIHtcbiAgY29uc29sZS5sb2coZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ0cmFuc3BUZXh0XCIpLnZhbHVlKTtcbiAgdmFsX29wYWNpdHlNYXRjaCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwib3BhY2l0eU1hdGNoXCIpLnZhbHVlO1xuICB2YWxfb3BhY2l0eU5vTWF0Y2ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm9wYWNpdHlOb01hdGNoXCIpLnZhbHVlO1xuICBoaWdobGlnaHRpbmcoZGljdHMsIGRhdGFzZXQsIGNhdGVnb3JpZXMsIHNoYXBpbmdfY29sdW1uLCBjb2x1bW5zLCBjYXRlZ29yeV9zZWFyY2gsIGNhdGVnb3J5X3NlYXJjaF9kYXRhLCBmZWF0dXJlX2NvbHVtbiwgY29sb3JfY29sdW1uLCBjb2xvciwgem9vbWVkLCBuZWVkWm9vbSwgdHJhbnNwYXJlbnRfY29sdW1uLCB2YWxfb3BhY2l0eU1hdGNoLCB2YWxfb3BhY2l0eU5vTWF0Y2gpO1xuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBoYW5kbGVDaGVjazEoZXZlbnQpIHtcbiAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwidHJhbnNwVGV4dFwiKS52YWx1ZSkge1xuICAgIGhhbmRsZUNsaWNrMSgpO1xuICB9XG59XG5cbi8vID8/IEkgYmVsaWV2ZSB0aGlzIGZ1bmN0aW9uIGlzIHVudXNlZCwgYW5kIGRyYXcgYWxzbyBtYXBzIHRvIGhhbmRsZUNsaWNrNFxuLy8gaXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIERyYXcgYnV0dG9uIGlzIHByZXNzZWQgYW5kIHRoZSBwbG90IHdpbGwgaGlnaGxpZ2h0IHRob3NlIHBvaW50cyB0aGF0IGNvdmVycyBmaXhlZCBwZXJjZW50YWdlIG9mIHBvaW50IGZyb20gdGhlIHBvaW50IG9idGFpbmVkIGJ5IG1vdXNlIGNsaWNrXG5mdW5jdGlvbiBoYW5kbGVDbGljazIoZXZlbnQpe1xuICBzaGFwaW5nX2NvbHVtbiA9IFwiU2VsZWN0XCI7XG4gIGNvbG9yX2NvbHVtbiA9IFwiU2VsZWN0XCI7XG4gIG15Rm9ybS5zZWFyY2hUZXh0LnZhbHVlID0gMDtcbiAgbXlGb3JtMS50cmFuc3BUZXh0LnZhbHVlID0gMDtcbiAgbXlGb3JtMS5vcGFjaXR5TWF0Y2gudmFsdWUgPSAwO1xuICBteUZvcm0xLm9wYWNpdHlOb01hdGNoLnZhbHVlID0gMDtcbiAgZHJvcERvd240LnByb3BlcnR5KCBcInZhbHVlXCIsIFwiU2VsZWN0XCIgKTtcbiAgZHJvcERvd24ucHJvcGVydHkoIFwidmFsdWVcIiwgXCJTZWxlY3RcIiApO1xuICBoaWdobGlnaHRpbmcoZGljdHMsIGRhdGFzZXQsIGNhdGVnb3JpZXMsIHNoYXBpbmdfY29sdW1uLCBjb2x1bW5zLCBjYXRlZ29yeV9zZWFyY2gsIGNhdGVnb3J5X3NlYXJjaF9kYXRhLCBmZWF0dXJlX2NvbHVtbiwgY29sb3JfY29sdW1uLCBjb2xvciwgem9vbWVkLCBuZWVkWm9vbSwgdHJhbnNwYXJlbnRfY29sdW1uLCBcIlwiLCBcIlwiLCBcIlwiKTtcbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBzcGVjdHJ1bSAvIGxvZyBldmVudFxuLy8gaXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIHNwZWN0cnVtL2xvZyBpcyBjaGVja2VkXG4vLyA/PyBDYW4gd2UgY29sbGFwc2UgaGFuZGxlQ2xpY2sxLDMsND9cbmZ1bmN0aW9uIGhhbmRsZUNsaWNrMyhldmVudCkge1xuICB2YWxfb3BhY2l0eU1hdGNoID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJvcGFjaXR5TWF0Y2hcIikudmFsdWU7XG4gIHZhbF9vcGFjaXR5Tm9NYXRjaCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwib3BhY2l0eU5vTWF0Y2hcIikudmFsdWU7XG4gIGhpZ2hsaWdodGluZyhkaWN0cywgZGF0YXNldCwgY2F0ZWdvcmllcywgc2hhcGluZ19jb2x1bW4sIGNvbHVtbnMsIGNhdGVnb3J5X3NlYXJjaCwgY2F0ZWdvcnlfc2VhcmNoX2RhdGEsIGZlYXR1cmVfY29sdW1uLCBjb2xvcl9jb2x1bW4sIGNvbG9yLCB6b29tZWQsIG5lZWRab29tLCB0cmFuc3BhcmVudF9jb2x1bW4sIHZhbF9vcGFjaXR5TWF0Y2gsIHZhbF9vcGFjaXR5Tm9NYXRjaCk7XG59XG5cbi8vIGl0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiAoPz8gZHJhdyBhbmQpIHpvb20gYnV0dG9uIGlzIHByZXNzZWQgYW5kIHRoZSBwbG90IHdpbGwgem9vbWVkIG91dCBhY2NvcmRpbmcgdG8gdGhlIHBvaW50cyBvYnRhaW5lZCBieSBtb3VzZSBjbGljayBldmVudFxuZnVuY3Rpb24gaGFuZGxlQ2xpY2s0KCl7XG4gIGlmICghZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Nib3gzJykuY2hlY2tlZCkge1xuICAgICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJ6b29teHlcIikudmFsdWUgPSBcIlwiOyAvLyBjbGVhciB0aGUgdGV4dGJveFxuICAgIH1cblxuICAgIHZhbF9vcGFjaXR5TWF0Y2ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm9wYWNpdHlNYXRjaFwiKS52YWx1ZTtcbiAgICB2YWxfb3BhY2l0eU5vTWF0Y2ggPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm9wYWNpdHlOb01hdGNoXCIpLnZhbHVlO1xuICAgIG5lZWRab29tID0gdHJ1ZTtcbiAgICBoaWdobGlnaHRpbmcoZGljdHMsIGRhdGFzZXQsIGNhdGVnb3JpZXMsIHNoYXBpbmdfY29sdW1uLCBjb2x1bW5zLCBjYXRlZ29yeV9zZWFyY2gsIGNhdGVnb3J5X3NlYXJjaF9kYXRhLCBmZWF0dXJlX2NvbHVtbiwgY29sb3JfY29sdW1uLCBjb2xvciwgem9vbWVkLCBuZWVkWm9vbSwgdHJhbnNwYXJlbnRfY29sdW1uLCB2YWxfb3BhY2l0eU1hdGNoLCB2YWxfb3BhY2l0eU5vTWF0Y2gpO1xuICB9XG5cblxuZnVuY3Rpb24gbGluc3BhY2Uoc3RhcnQsIGVuZCwgbikge1xuICB2YXIgb3V0ID0gW107XG4gIHZhciBkZWx0YSA9IChlbmQgLSBzdGFydCkgLyAobiAtIDEpO1xuICB2YXIgaSA9IDA7XG4gIHdoaWxlKGkgPCAobiAtIDEpKSB7XG4gICAgb3V0LnB1c2goc3RhcnQgKyAoaSAqIGRlbHRhKSk7XG4gICAgaSsrO1xuICB9XG4gIG91dC5wdXNoKGVuZCk7XG4gIHJldHVybiBvdXQ7XG59XG5cbi8vIHByb3ZpZGVzIGRpZmZlcmVudCBjb2xvcmVkIHNwZWN0cnVtXG52YXIgc2NhbGVfZCA9IHtcbiAgJ3B1T3IxMSc6IFsnIzdmM2IwOCcsICcjYjM1ODA2JywgJyNlMDgyMTQnLCAnI2ZkYjg2MycsICcjZmVlMGI2JywgJyNmN2Y3ZjcnLCAnI2Q4ZGFlYicsICcjYjJhYmQyJywgJyM4MDczYWMnLCAnIzU0Mjc4OCcsICcjMmQwMDRiJ10sXG4gICdzcGVjdHJhbDgnOiBbJyNkNTNlNGYnLCAnI2Y0NmQ0MycsICcjZmRhZTYxJywgJyNmZWUwOGInLCAnI2U2ZjU5OCcsICcjYWJkZGE0JywgJyM2NmMyYTUnLCAnIzMyODhiZCddLFxuICAncmVkQmxhY2tHcmVlbic6IFsnI2ZmMDAwMCcsICcjQUEwMDAwJywgJyM1NTAwMDAnLCAnIzAwNTUwMCcsICcjMDBBQTAwJywgJyMwMGZmMDAnXSxcbn07XG5sZXQgc2NhbGUgPSBzY2FsZV9kWydzcGVjdHJhbDgnXTtcbiJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQVVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Iiwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/main.js\n");

/***/ }),

/***/ "./src/modules/color_helpers.js":
/*!**************************************!*\
  !*** ./src/modules/color_helpers.js ***!
  \**************************************/
/*! exports provided: cValue */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"cValue\", function() { return cValue; });\n// Coloring helpers\n\n\n// What is d referring to here? Data? can we come up with a better name?\nfunction cValue(d) {\n\tlet key = \"color_column\";\n\tif (typeof color_column !== 'undefined') key = color_column;\n\treturn d[key];\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbW9kdWxlcy9jb2xvcl9oZWxwZXJzLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvY29sb3JfaGVscGVycy5qcz80NTUyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIENvbG9yaW5nIGhlbHBlcnNcblxuXG4vLyBXaGF0IGlzIGQgcmVmZXJyaW5nIHRvIGhlcmU/IERhdGE/IGNhbiB3ZSBjb21lIHVwIHdpdGggYSBiZXR0ZXIgbmFtZT9cbmV4cG9ydCBmdW5jdGlvbiBjVmFsdWUoZCkge1xuXHRsZXQga2V5ID0gXCJjb2xvcl9jb2x1bW5cIjtcblx0aWYgKHR5cGVvZiBjb2xvcl9jb2x1bW4gIT09ICd1bmRlZmluZWQnKSBrZXkgPSBjb2xvcl9jb2x1bW47XG5cdHJldHVybiBkW2tleV07XG59O1xuIl0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOyIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/modules/color_helpers.js\n");

/***/ }),

/***/ "./src/modules/constants.js":
/*!**********************************!*\
  !*** ./src/modules/constants.js ***!
  \**********************************/
/*! exports provided: margin, width, height, d3_category20_shuffled */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"margin\", function() { return margin; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"width\", function() { return width; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"height\", function() { return height; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"d3_category20_shuffled\", function() { return d3_category20_shuffled; });\n// Hardcoded values\nconst margin = { top: 90, right: 40, bottom: 40, left: 40 };\nconst width = 700 - margin.left - margin.right;\nconst height = 750 - margin.top - margin.bottom;\n\n// Can generate more with http://jnnnnn.github.io/category-colors-2L-inplace.html if want more\nconst d3_category20_shuffled = [\n\t\"#1f77b4\",\n\t\"#ff7f0e\",\n\t\"#2ca02c\",\n\t\"#d62728\",\n\t\"#9467bd\",\n\t\"#8c564b\",\n\t\"#e377c2\",\n\t\"#7f7f7f\",\n\t\"#bcbd22\",\n\t\"#17becf\",\n\t\"#aec7e8\",\n\t\"#ffbb78\",\n\t\"#98df8a\",\n\t\"#ff9896\",\n\t\"#c5b0d5\",\n\t\"#c49c94\",\n\t\"#f7b6d2\",\n\t\"#c7c7c7\",\n\t\"#dbdb8d\",\n\t\"#9edae5\"\n];//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbW9kdWxlcy9jb25zdGFudHMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9jb25zdGFudHMuanM/MzRiOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBIYXJkY29kZWQgdmFsdWVzXG5leHBvcnQgY29uc3QgbWFyZ2luID0geyB0b3A6IDkwLCByaWdodDogNDAsIGJvdHRvbTogNDAsIGxlZnQ6IDQwIH07XG5leHBvcnQgY29uc3Qgd2lkdGggPSA3MDAgLSBtYXJnaW4ubGVmdCAtIG1hcmdpbi5yaWdodDtcbmV4cG9ydCBjb25zdCBoZWlnaHQgPSA3NTAgLSBtYXJnaW4udG9wIC0gbWFyZ2luLmJvdHRvbTtcblxuLy8gQ2FuIGdlbmVyYXRlIG1vcmUgd2l0aCBodHRwOi8vam5ubm5uLmdpdGh1Yi5pby9jYXRlZ29yeS1jb2xvcnMtMkwtaW5wbGFjZS5odG1sIGlmIHdhbnQgbW9yZVxuZXhwb3J0IGNvbnN0IGQzX2NhdGVnb3J5MjBfc2h1ZmZsZWQgPSBbXG5cdFwiIzFmNzdiNFwiLFxuXHRcIiNmZjdmMGVcIixcblx0XCIjMmNhMDJjXCIsXG5cdFwiI2Q2MjcyOFwiLFxuXHRcIiM5NDY3YmRcIixcblx0XCIjOGM1NjRiXCIsXG5cdFwiI2UzNzdjMlwiLFxuXHRcIiM3ZjdmN2ZcIixcblx0XCIjYmNiZDIyXCIsXG5cdFwiIzE3YmVjZlwiLFxuXHRcIiNhZWM3ZThcIixcblx0XCIjZmZiYjc4XCIsXG5cdFwiIzk4ZGY4YVwiLFxuXHRcIiNmZjk4OTZcIixcblx0XCIjYzViMGQ1XCIsXG5cdFwiI2M0OWM5NFwiLFxuXHRcIiNmN2I2ZDJcIixcblx0XCIjYzdjN2M3XCIsXG5cdFwiI2RiZGI4ZFwiLFxuXHRcIiM5ZWRhZTVcIlxuXTsiXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/modules/constants.js\n");

/***/ }),

/***/ "./src/modules/highlighting.js":
/*!*************************************!*\
  !*** ./src/modules/highlighting.js ***!
  \*************************************/
/*! exports provided: highlighting */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"highlighting\", function() { return highlighting; });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./src/modules/constants.js\");\n/* harmony import */ var _table_creator_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./table_creator.js */ \"./src/modules/table_creator.js\");\n/* harmony import */ var _tooltips_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./tooltips.js */ \"./src/modules/tooltips.js\");\n/* harmony import */ var _color_helpers_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./color_helpers.js */ \"./src/modules/color_helpers.js\");\n/* harmony import */ var _utilities_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utilities.js */ \"./src/modules/utilities.js\");\n\n\n\n\n// import { lassoStart, lassoDraw } from './lasso.js'\n\n\n// function for plotting\nfunction highlighting(dicts, dataset, categories, shaping_column, columns, category_search, category_search_data, feature_column, color_column, color, zoomed, needZoom, transparent_column, val_opacityMatch, val_opacityNoMatch) {\n  let x_max, x_min, y_max, y_min, svg;\n  let coordinatesx = [];\n  let coordinatesy = [];\n  let temp1 = [], temp2 = [], temp3 = [];\n  let dict1 = {};\n\n  let val_search = document.getElementById(\"searchText\").value;\n  let val_transp = document.getElementById(\"transpText\").value;\n\n  // to remove the existing svg plot if any and clear side table\n  _utilities_js__WEBPACK_IMPORTED_MODULE_4__[\"plotClearer\"].clearAll();\n\n  // function zoom() {\n  //  svg.attr(\"transform\", \"translate(\" + d3.event.translate + \")scale(\" + d3.event.scale + \")\");\n  //    }\n\n  // the location of svg image will be determined\n  svg = d3.select(\"body\").append(\"svg\")\n  .attr(\"width\", _constants_js__WEBPACK_IMPORTED_MODULE_0__[\"width\"] + _constants_js__WEBPACK_IMPORTED_MODULE_0__[\"margin\"].left + _constants_js__WEBPACK_IMPORTED_MODULE_0__[\"margin\"].right)\n  .attr(\"height\", _constants_js__WEBPACK_IMPORTED_MODULE_0__[\"height\"] + _constants_js__WEBPACK_IMPORTED_MODULE_0__[\"margin\"].top + _constants_js__WEBPACK_IMPORTED_MODULE_0__[\"margin\"].bottom)\n  .append(\"g\")\n  .attr(\"transform\",\"translate(\" + _constants_js__WEBPACK_IMPORTED_MODULE_0__[\"margin\"].left + \",\" + _constants_js__WEBPACK_IMPORTED_MODULE_0__[\"margin\"].top + \")\");\n\n  function lassoStart () {\n    _utilities_js__WEBPACK_IMPORTED_MODULE_4__[\"plotClearer\"].clearTable();\n    console.log(lasso)\n    lasso.items()\n         .attr(\"r\",3.5) // reset size\n         .style(\"fill\",null) // clear all of the fills (greys out)\n         .classed({\"not_possible\":true,\"selected\":false}); // style as not possible\n  }\n\n  function lassoDraw() {\n    // Style the possible dots\n    lasso.items()\n         .filter((dot) => ( dot.possible === true ))\n         .classed({ \"not_possible\": false, \"possible\": true });\n\n    // Style the not possible dot\n    lasso.items()\n         .filter((d) => ( d.possible === false ))\n         .classed({\"not_possible\":true,\"possible\":false})\n         .style(\"stroke\", \"#000\");\n  };\n\n\n    var lasso_end = function() {\n      // Reset the color of all dots\n      lasso.items()\n      .style(\"fill\", function(d) { return color(d[color_column]); });\n\n      // Style the selected dots\n      lasso.items().filter(function(d) {return d.selected===true})\n      .classed({\"not_possible\":false,\"possible\":false})\n      .attr(\"r\",6.5);\n\n      // get values for table -> array inside a list\n      var zsx = lasso.items().filter(function(d) {return d.selected===true});\n    let x_values = [];\n    let y_values = [];\n      // adjust the x and y values\n      for (var i=0; i<zsx[0].length; i++) {\n        x_values.push(((((zsx[0][i].getBBox().x+6.5) * (x_max - x_min))/_constants_js__WEBPACK_IMPORTED_MODULE_0__[\"width\"] + x_min )));\n        y_values.push(((((zsx[0][i].getBBox().y+6.5) * (y_min - y_max))/_constants_js__WEBPACK_IMPORTED_MODULE_0__[\"height\"] + y_max)));\n      }\n      var selected_data=[], selected_data_indices=[];\n      // Compare every selected point to all points (tempX)\n      // in order to match coordinates with actual data\n      for (var ii=0;ii<x_values.length;ii++) {\n        console.log(\"lasso_end gathering selected data\");\n        console.log(temp1.length);\n        for (var jj=0;jj<temp1.length;jj++) {\n          x_values[ii] = +(x_values[ii].toFixed(3));\n          y_values[ii] = +(y_values[ii].toFixed(5));\n          if ( (x_values[ii] === +(temp1[jj].toFixed(3))) && (y_values[ii] === +(temp2[jj].toFixed(5))) ) {\n            let all_values = {};\n            for (var k=1;k<categories.length;k++) {\n              all_values[categories[k]] = (dict1[categories[k]][jj]);\n            }\n            if(Object(_utilities_js__WEBPACK_IMPORTED_MODULE_4__[\"searchdic\"])(selected_data,all_values)==true){\n              selected_data.push(all_values);\n              selected_data_indices.push(jj);\n              break;\n            }\n          }\n        }\n      }\n      // render the table for the points selected by lasso\n      if (selected_data.length > 0) {\n        console.log(\"Rendering table...\");\n        console.log(selected_data);\n        console.log(columns);\n        console.log(x_values);\n        var peopleTable = Object(_table_creator_js__WEBPACK_IMPORTED_MODULE_1__[\"tabulate\"])(selected_data, columns, x_values);\n        if (\"semantic_model\" in dicts && dicts[\"semantic_model\"] == \"true\") {\n          console.log(\"Predicting words...\");\n          Object(_table_creator_js__WEBPACK_IMPORTED_MODULE_1__[\"classify\"])(selected_data_indices, vectorspace_2darray, weights_2darray, biases_1darray, vocab_1darray);\n          Object(_table_creator_js__WEBPACK_IMPORTED_MODULE_1__[\"benchmark\"])(selected_data_indices, bow_2darray, vocab_1darray);\n        }\n      }\n\n      // Reset the style of the not selected dots (we made them 0.5 smaller)\n      lasso.items().filter(function(d) {return d.selected===false})\n      .classed({\"not_possible\":false,\"possible\":false})\n      .attr(\"r\",3)\n      .style(\"stroke\", \"#000\");\n    };\n\n  // Create the area where the lasso event can be triggered\n  var lasso_area = svg.append(\"rect\")\n  .attr(\"width\",_constants_js__WEBPACK_IMPORTED_MODULE_0__[\"width\"])\n  .attr(\"height\",_constants_js__WEBPACK_IMPORTED_MODULE_0__[\"height\"])\n  .style(\"opacity\",0);\n\n  // Define the lasso\n  var lasso = d3.lasso()\n      .closePathDistance(75) // max distance for the lasso loop to be closed\n      .closePathSelect(true) // can items be selected by closing the path?\n      .hoverSelect(true) // can items by selected by hovering over them?\n      .area(lasso_area) // area where the lasso can be started\n      \n  lasso.on(\"start\",lassoStart) // lasso start function\n       .on(\"draw\",lassoDraw) // lasso draw function\n       .on(\"end\",lasso_end); // lasso end function\n\n  // Init the lasso object on the svg:g that contains the dots\n  svg.call(lasso);\n\n  console.log('Loading main data, again') // load data\n  d3.tsv(dataset, function(error, data) {\n\n      // change string (from CSV) into number format\n      var numerics = {}, symbol = {};\n      //Omitting Select (0)\n      for(var i=1;i<categories.length;i++) {\n          // initialize the value for each category key to empty list\n          dict1[categories[i]] = [];\n          // initialize all categories as numeric\n          numerics[categories[i]] = 1;\n        }\n        let counter = 0;\n        data.forEach(function(d) {\n          // coerce the data to numbers\n          d.x = +d.x;\n          d[\"y\"] = +d[\"y\"];\n\n          for(var i=1;i<categories.length;i++){\n              // add every attribute of point to the {category:[val1,val2,...]}\n              dict1[categories[i]].push(d[categories[i]]);\n              // revoke a category's numerics status if find an entry has a non-Int or non-null value for that category\n              numerics[categories[i]] = numerics[categories[i]] && (d[categories[i]] == \"\" || d[categories[i]] == parseFloat(d[categories[i]]));\n            }\n          // fill the symbol dictionary with all possible values of the shaping column as keys\n          // value is the order of points\n          if (!(d[shaping_column] in symbol)) {\n            symbol[d[shaping_column]] = counter;\n            counter = counter + 1;\n          }\n          // push all x values, y values, and all category search values into temp1/2/3\n          temp1.push(d.x);\n          temp2.push(d[\"y\"]);\n          temp3.push(d[category_search]);\n        // console.log(d[\"z\"] == parseInt(d[\"z\"]));\n      });\n        console.log(numerics);\n        console.log(color_column);\n      // set color according to spectrum\n      if (numerics[color_column] && document.getElementById('cbox1').checked) {\n        console.log('using spectrum');\n          // take log if log checkbox checked\n          if (document.getElementById('cbox2').checked) {\n            console.log('using log');\n            m1 = (d3.min(data.map(function(d) {return Math.log(parseFloat(d[color_column])); })));\n            m2 = (d3.max(data.map(function(d) {return Math.log(parseFloat(d[color_column])); })));\n          } else{\n            console.log('not using log');\n            m1 = (d3.min(data.map(function(d) {return parseFloat(d[color_column])})));\n            m2 = (d3.max(data.map(function(d) {return parseFloat(d[color_column])})));\n          }\n\n          console.log(m1, m2);\n          m1 = Math.max(Number.MIN_VALUE, m1);\n          console.log(m1, m2);\n\n          color = d3.scale.linear()\n          .domain(linspace(m1, m2,scale.length))\n            //.domain(linspace(d3.min(data.map(function(d) {return parseInt(d[color_column])})), d3.max(data.map(function(d) {return parseInt(d[color_column])})),scale.length))\n            .range(scale);\n          } else {\n            console.log('not using spectrum');\n            color = d3.scale.ordinal().range(_constants_js__WEBPACK_IMPORTED_MODULE_0__[\"d3_category20_shuffled\"]);\n          }\n\n      // don't want dots overlapping axis, so add in buffer to data domain\n      var zoom = Object(_utilities_js__WEBPACK_IMPORTED_MODULE_4__[\"getParameterByName\"])('Zoom'); // unused, capitalized Z anyway as changed above\n\n      if (document.getElementById(\"cbox3\").checked==false) {\n        document.getElementById(\"zoomxy\").value = \"\";\n        zoomed = 0;\n        needZoom = false;\n        x_max = d3.max(data, _utilities_js__WEBPACK_IMPORTED_MODULE_4__[\"xValue\"])+1;\n        x_min = d3.min(data, _utilities_js__WEBPACK_IMPORTED_MODULE_4__[\"xValue\"])-1;\n        y_max = d3.max(data, _utilities_js__WEBPACK_IMPORTED_MODULE_4__[\"yValue\"])+1;\n        y_min = d3.min(data, _utilities_js__WEBPACK_IMPORTED_MODULE_4__[\"yValue\"])-1;\n      }\n\n      // if zoom is checked and conditions are satisfied\n      if (document.getElementById(\"cbox3\").checked==true  && needZoom == true && coordinatesx.length >= 2) {\n\n        x_max = _utilities_js__WEBPACK_IMPORTED_MODULE_4__[\"xScale\"].invert(Math.max(coordinatesx[0], coordinatesx[1]))+1;\n        x_min = _utilities_js__WEBPACK_IMPORTED_MODULE_4__[\"xScale\"].invert(Math.min(coordinatesx[0], coordinatesx[1]))-1;\n        y_max = _utilities_js__WEBPACK_IMPORTED_MODULE_4__[\"yScale\"].invert(Math.min(coordinatesy[0], coordinatesy[1]))+1;\n        y_min = _utilities_js__WEBPACK_IMPORTED_MODULE_4__[\"yScale\"].invert(Math.max(coordinatesy[0], coordinatesy[1]))-1;\n\n        console.log(x_max, x_min, y_max, y_min);\n        document.getElementById(\"zoomxy\").value = \"X:[\"+parseInt(x_min)+\", \"+parseInt(x_max)+\"] Y:[\"+parseInt(y_min)+\", \"+parseInt(y_max)+\"]\";\n\n        zoomed = 1;\n        needZoom = false;\n                      }\n                      _utilities_js__WEBPACK_IMPORTED_MODULE_4__[\"xScale\"].domain([x_min, x_max]);\n                      _utilities_js__WEBPACK_IMPORTED_MODULE_4__[\"yScale\"].domain([y_min, y_max]);\n\n      // x-axis\n      let cx = 0;\n      let cy = 0;\n      let ans = 0;\n\n      // draw the x-axis of plot\n      svg.append(\"g\")\n      .attr(\"class\", \"x axis\")\n      .attr(\"transform\", \"translate(0,\" + _constants_js__WEBPACK_IMPORTED_MODULE_0__[\"height\"] + \")\")\n      .call(_utilities_js__WEBPACK_IMPORTED_MODULE_4__[\"xAxis\"])\n      .append(\"text\")\n      .attr(\"class\", \"label\")\n      .attr(\"x\", _constants_js__WEBPACK_IMPORTED_MODULE_0__[\"width\"])\n      .attr(\"y\", -6)\n      .style(\"text-anchor\", \"end\")\n      .text(\"\");\n\n      // draw the y-axis of plot\n      svg.append(\"g\")\n      .attr(\"class\", \"y axis\")\n      .call(_utilities_js__WEBPACK_IMPORTED_MODULE_4__[\"yAxis\"])\n      .append(\"text\")\n      .attr(\"class\", \"label\")\n      .attr(\"transform\", \"rotate(-90)\")\n      .attr(\"y\", 6)\n      .attr(\"dy\", \".71em\")\n      .style(\"text-anchor\", \"end\")\n      .text(\"\");\n\n      // to identify the condition of transparent column values\n      if (transparent_column !== \"Select\" && val_transp !== \"\" && val_opacityNoMatch !== \"\") {\n        transparent_column = transparent_column.toString();\n          val_transp = val_transp.toString(); // ?? no to lower case here?\n        }\n        else {\n          val_transp = val_transp.toString();\n        }\n\n        var transpar = function(d) {\n          if (val_transp !== \"\" && typeof d != 'undefined') {\n          // if point's transp column value is equal to the value specified, return val_opacityMatch, else val_opacityNoMatch\n          var match;\n          if (document.getElementById('cbox6').checked) {\n            match = d[transparent_column] == val_transp;\n          } else {\n            match = d[transparent_column] && (d[transparent_column].toLowerCase().indexOf(val_transp.toLowerCase()) > -1);\n          }\n\n          if (match) {\n            return parseFloat(val_opacityMatch);\n          } else{\n            return parseFloat(val_opacityNoMatch);\n          }\n          }\n          else {\n            return 1;\n          }\n        };\n\n      // searching according to the substring given and searching column\n      var searchFunc = function(d) {\n        if (typeof d[category_search] == 'undefined' ) {\n          return 1;\n        }\n          // noMatch truthy if not found\n          var noMatch;\n          if (document.getElementById('cbox5').checked) {\n            noMatch = d[category_search] != val_search;\n          } else {\n            noMatch = d[category_search].toLowerCase().indexOf(val_search.toLowerCase()) < 0\n            || val_search.length === 0;\n          }\n          return noMatch ? 1 : 2;\n        };\n\n        var searchFunc1 = function(d) {\n          if (typeof d == 'undefined' ) {\n            return 1;\n          }\n          // noMatch true if not found\n          var noMatch;\n          if (document.getElementById('cbox5').checked) {\n            noMatch = d != val_search;\n          } else {\n            noMatch = d.toLowerCase().indexOf(val_search.toLowerCase()) < 0\n            || val_search.length === 0;\n          }\n          return noMatch ? 1 : 2;\n        };\n\n        var searched_data = [], searched_data_indices = [], d_temp;\n        /* temp3 holds the value of every point for the search column */\n        for (var i=0;i<temp3.length;i++) {\n          // 0 if found val in this point, 1 if not found\n          if ( searchFunc1(temp3[i])-1 ) {\n            d_temp = {};\n              // enter all data into dictionary\n              for(var j=1;j<categories.length;j++) {\n                d_temp[categories[j]] = dict1[categories[j]][i];\n              }\n              // only add to searched_data if not already in\n              if(Object(_utilities_js__WEBPACK_IMPORTED_MODULE_4__[\"searchdic\"])(searched_data, d_temp) === true) {\n                searched_data.push(d_temp);\n                searched_data_indices.push(i);\n              }\n            }\n          }\n      // create the table\n      if ( val_search != \"\" && searched_data.length > 0) {\n        var peopleTable1 = Object(_table_creator_js__WEBPACK_IMPORTED_MODULE_1__[\"tabulate\"])(searched_data, columns);\n        if (\"semantic_model\" in dicts && dicts[\"semantic_model\"] == \"true\") {\n          console.log(\"Predicting words...\");\n          Object(_table_creator_js__WEBPACK_IMPORTED_MODULE_1__[\"classify\"])(searched_data_indices, vectorspace_2darray, weights_2darray, biases_1darray, vocab_1darray);\n          Object(_table_creator_js__WEBPACK_IMPORTED_MODULE_1__[\"benchmark\"])(searched_data_indices, bow_2darray, vocab_1darray);\n        }\n      };\n\n      // determines the rotation of symbols that can be done\n      var sizes = {}\n      sizes[0] = [\"0\", \"90\", \"0\", \"0\"]\n      sizes[1] = [\"0\", \"45\", \"0\", \"0\"]\n      sizes[2] = [\"0\", \"90\", \"0\", \"0\"]\n      sizes[3] = [\"0\", \"45\", \"0\", \"0\"]\n      sizes[4] = [\"0\", \"90\", \"0\", \"0\"]\n      sizes[5] = [\"0\", \"0\", \"0\", \"0\"]\n      var symbols = [\"diamond\", \"cross\", \"triangle-up\", \"square\", \"triangle-down\",\"circle\"];\n\n      /*** BEGIN drawing dots ***/\n\n      // shaping of symbols according to the shaping column\n      if (shaping_column !== \"Select\" ) {\n        // color_column = shaping_column;\n        var points = svg.selectAll(\".dot\")\n        .data(data)\n        .enter();\n\n        points.append(\"path\")\n              .filter(function(d){ return (searchFunc(d) == 1); })\n              .attr(\"class\", \"point\")\n              .style(\"stroke\", \"#000\")\n              .style(\"stroke-width\", 1)\n        // .attr(\"d\", d3.svg.symbol().type(function(d) {return symbols[symbol[d[shaping_column]]%6];}).size( function(d) {return sizes[parseInt(symbol[d[shaping_column]]/6)%4];}))\n        .attr(\"d\", d3.svg.symbol().type(function(d) {return symbols[symbol[d[shaping_column]]%6];}).size(function(d) {return searchFunc(d)-1 ? 180:30;}))\n        .attr(\"transform\", function(d) { return \"translate(\" + Object(_utilities_js__WEBPACK_IMPORTED_MODULE_4__[\"xMap\"])(d) + \",\" + Object(_utilities_js__WEBPACK_IMPORTED_MODULE_4__[\"yMap\"])(d) + \") rotate(\" + sizes[parseInt(symbol[d[shaping_column]]%6)][parseInt(symbol[d[shaping_column]]/6)%4] + \")\"; })\n        .style(\"fill\", function(d) { return document.getElementById('cbox2').checked ? color(cValue2(d)) : color(Object(_color_helpers_js__WEBPACK_IMPORTED_MODULE_3__[\"cValue\"])(d));})\n        .style(\"opacity\",function(d) { return transpar(d);})\n\n        .on(\"mouseover\", function(d) {\n          _tooltips_js__WEBPACK_IMPORTED_MODULE_2__[\"tooltip\"].transition()\n          .duration(200)\n          .style(\"opacity\", 1);\n          _tooltips_js__WEBPACK_IMPORTED_MODULE_2__[\"tooltip\"].html(\n            Object(_utilities_js__WEBPACK_IMPORTED_MODULE_4__[\"printArray\"])(category_search_data, d))\n          .style(\"left\", 60 + \"px\")\n          .style(\"top\", 30 + \"px\");\n        })\n        .on(\"mouseout\", function(d) {\n          d3.select(this).attr(\"r\", function(d){ return searchFunc(d)-1 ? 7:3 ; })\n          .style(\"fill\", function(d) { return color(Object(_color_helpers_js__WEBPACK_IMPORTED_MODULE_3__[\"cValue\"])(d));});\n          _tooltips_js__WEBPACK_IMPORTED_MODULE_2__[\"tooltip\"].transition()\n          .duration(500)\n          .style(\"opacity\", 0);\n        })\n        .on(\"click\", function(d) {\n          svg.append(\"text\")\n          .text(d[feature_column])\n          .attr(\"x\", (d3.event.pageX-50))\n          .attr(\"y\", (d3.event.pageY-35));\n        });\n\n        points.append(\"path\")\n        .filter(function(d){ return (searchFunc(d) == 2); })\n        .attr(\"class\", \"point\")\n        .style(\"stroke\", \"yellow\")\n        .style(\"stroke-width\", 2)\n        // .attr(\"d\", d3.svg.symbol().type(function(d) {return symbols[symbol[d[shaping_column]]%6];}).size( function(d) {return sizes[parseInt(symbol[d[shaping_column]]/6)%4];}))\n        .attr(\"d\", d3.svg.symbol().type(function(d) {return symbols[symbol[d[shaping_column]]%6];}).size(function(d) {return searchFunc(d)-1 ? 180:30;}))\n        .attr(\"transform\", function(d) { return \"translate(\" + Object(_utilities_js__WEBPACK_IMPORTED_MODULE_4__[\"xMap\"])(d) + \",\" + Object(_utilities_js__WEBPACK_IMPORTED_MODULE_4__[\"yMap\"])(d) + \") rotate(\" + sizes[parseInt(symbol[d[shaping_column]]%6)][parseInt(symbol[d[shaping_column]]/6)%4] + \")\"; })\n        .style(\"fill\", function(d) { return document.getElementById('cbox2').checked ? color(cValue2(d)) : color(Object(_color_helpers_js__WEBPACK_IMPORTED_MODULE_3__[\"cValue\"])(d));})\n        .style(\"opacity\",function(d) { return transpar(d);})\n\n        .on(\"mouseover\", function(d) {\n          _tooltips_js__WEBPACK_IMPORTED_MODULE_2__[\"tooltip\"].transition()\n          .duration(200)\n          .style(\"opacity\", 1);\n          _tooltips_js__WEBPACK_IMPORTED_MODULE_2__[\"tooltip\"].html(\n            Object(_utilities_js__WEBPACK_IMPORTED_MODULE_4__[\"printArray\"])(category_search_data, d))\n          .style(\"left\", 60 + \"px\")\n          .style(\"top\", 30 + \"px\");\n        })\n        .on(\"mouseout\", function(d) {\n          d3.select(this).attr(\"r\", function(d){ return searchFunc(d)-1 ? 7:3 ; })\n          .style(\"fill\", function(d) { return color(Object(_color_helpers_js__WEBPACK_IMPORTED_MODULE_3__[\"cValue\"])(d));});\n          _tooltips_js__WEBPACK_IMPORTED_MODULE_2__[\"tooltip\"].transition()\n          .duration(500)\n          .style(\"opacity\", 0);\n        })\n        .on(\"click\", function(d) {\n          svg.append(\"text\")\n          .text(d[feature_column])\n          .attr(\"x\", (d3.event.pageX-50))\n          .attr(\"y\", (d3.event.pageY-35));\n        });\n      } else {\n        // draw dots\n        let marked = {}\n        var points = svg.selectAll(\".dot\")\n        .data(data)\n        .enter();\n\n        points.append(\"circle\")\n        .filter(function(d){ return (searchFunc(d) == 1); })\n        .attr(\"class\", \"dot\")\n        .attr(\"r\", 3)\n        .style(\"stroke\", \"#000\")\n        .style(\"stroke-width\", 1)\n        .attr(\"cx\", _utilities_js__WEBPACK_IMPORTED_MODULE_4__[\"xMap\"])\n        .attr(\"cy\", _utilities_js__WEBPACK_IMPORTED_MODULE_4__[\"yMap\"])\n        .style(\"fill\", function(d) { return document.getElementById('cbox2').checked ? color(cValue2(d)) : color(Object(_color_helpers_js__WEBPACK_IMPORTED_MODULE_3__[\"cValue\"])(d));})\n        .style(\"opacity\",function(d) { return transpar(d);})\n\n        .on(\"mouseover\", function(d) {\n          _tooltips_js__WEBPACK_IMPORTED_MODULE_2__[\"tooltip\"].transition()\n          .duration(200)\n          .style(\"opacity\", 1);\n          _tooltips_js__WEBPACK_IMPORTED_MODULE_2__[\"tooltip\"].html(Object(_utilities_js__WEBPACK_IMPORTED_MODULE_4__[\"printArray\"])(category_search_data, d))\n          .style(\"left\", 60 + \"px\")\n          .style(\"top\", 30 + \"px\");\n        })\n\n        .on(\"mouseout\", function(d) {\n          _tooltips_js__WEBPACK_IMPORTED_MODULE_2__[\"tooltip\"].transition()\n          .duration(500)\n          .style(\"opacity\", 0);\n        })\n\n        .on(\"click\", function(d) {\n          if (!([d3.event.pageX, d3.event.pageY] in marked)) {\n            marked[[d3.event.pageX, d3.event.pageY]] = true;\n            marked[[d3.event.pageX-1, d3.event.pageY-1]] = true;\n            marked[[d3.event.pageX+1, d3.event.pageY+1]] = true;\n            marked[[d3.event.pageX-1, d3.event.pageY+1]] = true;\n            marked[[d3.event.pageX+1, d3.event.pageY-1]] = true;\n            marked[[d3.event.pageX+2, d3.event.pageY-2]] = true;\n            marked[[d3.event.pageX-2, d3.event.pageY-2]] = true;\n            marked[[d3.event.pageX-2, d3.event.pageY+2]] = true;\n            marked[[d3.event.pageX+2, d3.event.pageY+2]] = true;\n            svg.append(\"text\")\n            .text(d[feature_column])\n            .attr(\"x\", (d3.event.pageX-50))\n            .attr(\"y\", (d3.event.pageY-35));\n                    /*\n                    tooltip1.transition()\n                       .attr(\"class\", \"tooltip1\")\n                             .style(\"opacity\", 1);\n\n                    tooltip1.html(\"<b>\"+d[feature_column]+\"</b>\")\n                             .style(\"left\", (d3.event.pageX + 10) + \"px\")\n                             .style(\"top\", (d3.event.pageY - 10) + \"px\");\n                             */\n                           }\n                         });\n        points.append(\"circle\")\n        .filter(function(d){ return (searchFunc(d) == 2); })\n        .attr(\"class\", \"dot\")\n        .attr(\"r\", 7)\n        .style(\"stroke\", \"yellow\")\n        .style(\"stroke-width\", 2)\n        .attr(\"cx\", _utilities_js__WEBPACK_IMPORTED_MODULE_4__[\"xMap\"])\n        .attr(\"cy\", _utilities_js__WEBPACK_IMPORTED_MODULE_4__[\"yMap\"])\n        .style(\"fill\", function(d) { return document.getElementById('cbox2').checked ? color(cValue2(d)) : color(Object(_color_helpers_js__WEBPACK_IMPORTED_MODULE_3__[\"cValue\"])(d));})\n        .style(\"opacity\",function(d) { return transpar(d);})\n          // jann: here is the mouseover display\n          .on(\"mouseover\", function(d) {\n            _tooltips_js__WEBPACK_IMPORTED_MODULE_2__[\"tooltip\"].transition()\n            .duration(200)\n            .style(\"opacity\", 1);\n            _tooltips_js__WEBPACK_IMPORTED_MODULE_2__[\"tooltip\"].html(\n              Object(_utilities_js__WEBPACK_IMPORTED_MODULE_4__[\"printArray\"])(category_search_data, d))\n            .style(\"left\", 60 + \"px\")\n            .style(\"top\", 30 + \"px\");\n          })\n\n          .on(\"mouseout\", function(d) {\n            _tooltips_js__WEBPACK_IMPORTED_MODULE_2__[\"tooltip\"].transition()\n            .duration(500)\n            .style(\"opacity\", 0);\n          })\n\n          .on(\"click\", function(d) {\n            if (!([d3.event.pageX, d3.event.pageY] in marked)){\n              marked[[d3.event.pageX, d3.event.pageY]] = true;\n              marked[[d3.event.pageX-1, d3.event.pageY-1]] = true;\n              marked[[d3.event.pageX+1, d3.event.pageY+1]] = true;\n              marked[[d3.event.pageX-1, d3.event.pageY+1]] = true;\n              marked[[d3.event.pageX+1, d3.event.pageY-1]] = true;\n              marked[[d3.event.pageX+2, d3.event.pageY-2]] = true;\n              marked[[d3.event.pageX-2, d3.event.pageY-2]] = true;\n              marked[[d3.event.pageX-2, d3.event.pageY+2]] = true;\n              marked[[d3.event.pageX+2, d3.event.pageY+2]] = true;\n              svg.append(\"text\")\n              .text(d[feature_column])\n              .attr(\"x\", (d3.event.pageX-50))\n              .attr(\"y\", (d3.event.pageY-35));\n            }\n          });\n        }\n        /*** END drawing dots ***/\n\n      // the event to call on click event\n      svg.on(\"click\",function() {\n        // svg.select(\"#myText\").remove();\n\n        _tooltips_js__WEBPACK_IMPORTED_MODULE_2__[\"tooltip1\"].style(\"opacity\", 0);\n        var coordinates1 = d3.mouse(this);\n        coordinatesx.unshift(coordinates1[0]);\n        coordinatesy.unshift(coordinates1[1]);\n        console.log(coordinatesx, coordinatesy);\n      })\n\n      /* can move up into the if/else, but more clear to separate functionality */\n      if (shaping_column !== \"Select\" ) {\n        lasso.items(d3.selectAll(\".dot\"));\n      } else {\n        lasso.items(d3.selectAll(\".dot\"));\n      }\n\n      var len = color.domain().length;\n      // if spectrum\n      if (numerics[color_column] && document.getElementById('cbox1').checked) {\n\n        if (document.getElementById('cbox2').checked) {\n          m1 = (d3.min(data.map(function(d) {return Math.log(parseFloat(d[color_column])); })));\n          m2 = (d3.max(data.map(function(d) {return Math.log(parseFloat(d[color_column])); })));\n        } else {\n          m1 = (d3.min(data.map(function(d) {return parseFloat(d[color_column])})));\n          m2 = (d3.max(data.map(function(d) {return parseFloat(d[color_column])})));\n\n        }\n        console.log(m1, m2);\n        m1 = Math.max(Number.MIN_VALUE, m1);\n        console.log(m1, m2);\n\n        var legend = svg.selectAll(\".legend\")\n        .data(color.domain())\n        .enter().append(\"g\")\n        .attr(\"class\", \"legend\");\n\n        var gradient = legend.append('defs')\n        .append('linearGradient')\n        .attr('id', 'gradient')\n                  .attr('x1', '0%') // bottom\n                  .attr('y1', '100%')\n                  .attr('x2', '0%') // to top\n                  .attr('y2', '0%')\n                  .attr('spreadMethod', 'pad');\n\n                  var pct = linspace(0, 100, scale.length).map(function(d) {\n                    return Math.round(d) + '%';\n                  });\n\n                  var colourPct = d3.zip(pct, scale);\n                  colourPct.forEach(function(d) {\n                    gradient.append('stop')\n                    .attr('offset', d[0])\n                    .attr('stop-color', d[1])\n                    .attr('stop-opacity', 1);\n                  });\n\n                  legend.append('rect')\n                  .attr('x1', 0)\n                  .attr('y1', 0)\n                  .attr('width', 18)\n                  .attr('height', 150)\n                  .attr(\"transform\", \"translate(\" + 582 + \", 0)\")\n                  .style('fill', 'url(#gradient)');\n\n                  var legendScale = d3.scale.linear()\n                  .domain([m1, m2])\n                  .range([150, 0]);\n\n                  var legendAxis = d3.svg.axis()\n                  .scale(legendScale)\n                  .orient(\"right\")\n              // .tickValues([m1, m2])\n              .ticks(10);\n\n              legend.append(\"g\")\n              .attr(\"class\", \"legend axis\")\n              .attr(\"transform\", \"translate(\" + 600 + \", 0)\")\n              .call(legendAxis);\n      } else { // no spectrum\n        console.log(Object);\n        var keys = Object.keys(symbol);\n        let leng = keys.length;\n        if (leng<20 && shaping_column != \"Select\") {\n            // draw legend\n              // ?? Not sure why, but this legend appears not to show\n              var legend = svg.selectAll(\".legend\")\n              .data(keys)\n              .enter().append(\"g\");\n                  // .attr(\"class\", \"legend\");\n                  // .attr(\"transform\", function(d, i) { return \"translate(30,\" + i * 20 + \")\"; });\n                  console.log(keys);\n                  console.log(shaping_column);\n                  console.log(symbol);\n                  console.log(symbols);\n              // draw legend colored rectangles\n              legend.append(\"path\")\n                  // .attr(\"d\", d3.svg.symbol().type(function(d) {return symbols[symbol[d]%6];}).size(function(d) {return sizes[parseInt(symbol[d]/6)%3];}))\n                  .attr(\"d\", d3.svg.symbol().type(function(d) {return symbols[symbol[d]%6];}))\n                  .attr(\"x\", _constants_js__WEBPACK_IMPORTED_MODULE_0__[\"width\"] + 0)\n                  .attr(\"width\", 18)\n                  .attr(\"height\", 18)\n                  // .attr(\"transform\", function(d, i) { return \"translate(\" + 20 + \",\" + i*20 + \")\"; });\n                  .attr(\"transform\", function(d, i) { return \"translate(\" + 20 + \",\" + i*20 + \") rotate(\" + sizes[parseInt(symbol[d]%6)][parseInt(symbol[d]/6)%4] + \")\"; });\n              // draw legend text\n              legend.append(\"text\")\n                  // .attr(\"x\", 100 + 0)\n                  // .attr(\"y\", 4)\n                  .attr(\"dy\", \".35em\")\n                  .style(\"text-anchor\", \"begin\")\n                  .text(function(d) { return d;})\n                  .attr(\"transform\", function(d, i) { return \"translate(30,\" + i * 20 + \")\"; });\n                }\n\n                if(len <= 30 && color_column != \"Select\") {\n\n              // draw legend\n              var legend = svg.selectAll(\".legend\")\n              .data(color.domain())\n              .enter().append(\"g\")\n              .attr(\"class\", \"legend\")\n              .attr(\"transform\", function(d, i) { return \"translate(0,\" + i * 20 + \")\"; });\n\n              // draw legend colored rectangles\n              legend.append(\"rect\")\n              .attr(\"x\", _constants_js__WEBPACK_IMPORTED_MODULE_0__[\"width\"] + 6)\n              .attr(\"width\", 18)\n              .attr(\"height\", 18)\n              .style(\"fill\", color);\n\n              // draw legend text\n              legend.append(\"text\")\n              .attr(\"x\", _constants_js__WEBPACK_IMPORTED_MODULE_0__[\"width\"] + 0)\n              .attr(\"y\", 9)\n              .attr(\"dy\", \".35em\")\n              .style(\"text-anchor\", \"end\")\n              .text(function(d) { return d;});\n            }\n          };\n  }); // end load data\n} // end highlighting//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbW9kdWxlcy9oaWdobGlnaHRpbmcuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy9oaWdobGlnaHRpbmcuanM/NjFlYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBtYXJnaW4sIHdpZHRoLCBoZWlnaHQsIGQzX2NhdGVnb3J5MjBfc2h1ZmZsZWQgfSBmcm9tICcuL2NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBjbGFzc2lmeSwgYmVuY2htYXJrLCB0YWJ1bGF0ZSB9IGZyb20gJy4vdGFibGVfY3JlYXRvci5qcyc7XG5pbXBvcnQgeyB0b29sdGlwLCB0b29sdGlwMSB9IGZyb20gJy4vdG9vbHRpcHMuanMnXG5pbXBvcnQgeyBjVmFsdWUgfSBmcm9tICcuL2NvbG9yX2hlbHBlcnMuanMnXG4vLyBpbXBvcnQgeyBsYXNzb1N0YXJ0LCBsYXNzb0RyYXcgfSBmcm9tICcuL2xhc3NvLmpzJ1xuaW1wb3J0IHsgcGxvdENsZWFyZXIsIFxuICAgICAgICAgc2VhcmNoZGljLCBcbiAgICAgICAgIGdldFBhcmFtZXRlckJ5TmFtZSxcbiAgICAgICAgIHByaW50QXJyYXksXG4gICAgICAgICB4VmFsdWUsXG4gICAgICAgICB5VmFsdWUsXG4gICAgICAgICB4U2NhbGUsXG4gICAgICAgICB5U2NhbGUsXG4gICAgICAgICB4TWFwLFxuICAgICAgICAgeU1hcCxcbiAgICAgICAgIHhBeGlzLFxuICAgICAgICAgeUF4aXMgXG4gICAgICAgfSBmcm9tICcuL3V0aWxpdGllcy5qcyc7XG5cbi8vIGZ1bmN0aW9uIGZvciBwbG90dGluZ1xuZXhwb3J0IGZ1bmN0aW9uIGhpZ2hsaWdodGluZyhkaWN0cywgZGF0YXNldCwgY2F0ZWdvcmllcywgc2hhcGluZ19jb2x1bW4sIGNvbHVtbnMsIGNhdGVnb3J5X3NlYXJjaCwgY2F0ZWdvcnlfc2VhcmNoX2RhdGEsIGZlYXR1cmVfY29sdW1uLCBjb2xvcl9jb2x1bW4sIGNvbG9yLCB6b29tZWQsIG5lZWRab29tLCB0cmFuc3BhcmVudF9jb2x1bW4sIHZhbF9vcGFjaXR5TWF0Y2gsIHZhbF9vcGFjaXR5Tm9NYXRjaCkge1xuICBsZXQgeF9tYXgsIHhfbWluLCB5X21heCwgeV9taW4sIHN2ZztcbiAgbGV0IGNvb3JkaW5hdGVzeCA9IFtdO1xuICBsZXQgY29vcmRpbmF0ZXN5ID0gW107XG4gIGxldCB0ZW1wMSA9IFtdLCB0ZW1wMiA9IFtdLCB0ZW1wMyA9IFtdO1xuICBsZXQgZGljdDEgPSB7fTtcblxuICBsZXQgdmFsX3NlYXJjaCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwic2VhcmNoVGV4dFwiKS52YWx1ZTtcbiAgbGV0IHZhbF90cmFuc3AgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInRyYW5zcFRleHRcIikudmFsdWU7XG5cbiAgLy8gdG8gcmVtb3ZlIHRoZSBleGlzdGluZyBzdmcgcGxvdCBpZiBhbnkgYW5kIGNsZWFyIHNpZGUgdGFibGVcbiAgcGxvdENsZWFyZXIuY2xlYXJBbGwoKTtcblxuICAvLyBmdW5jdGlvbiB6b29tKCkge1xuICAvLyAgc3ZnLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBkMy5ldmVudC50cmFuc2xhdGUgKyBcIilzY2FsZShcIiArIGQzLmV2ZW50LnNjYWxlICsgXCIpXCIpO1xuICAvLyAgICB9XG5cbiAgLy8gdGhlIGxvY2F0aW9uIG9mIHN2ZyBpbWFnZSB3aWxsIGJlIGRldGVybWluZWRcbiAgc3ZnID0gZDMuc2VsZWN0KFwiYm9keVwiKS5hcHBlbmQoXCJzdmdcIilcbiAgLmF0dHIoXCJ3aWR0aFwiLCB3aWR0aCArIG1hcmdpbi5sZWZ0ICsgbWFyZ2luLnJpZ2h0KVxuICAuYXR0cihcImhlaWdodFwiLCBoZWlnaHQgKyBtYXJnaW4udG9wICsgbWFyZ2luLmJvdHRvbSlcbiAgLmFwcGVuZChcImdcIilcbiAgLmF0dHIoXCJ0cmFuc2Zvcm1cIixcInRyYW5zbGF0ZShcIiArIG1hcmdpbi5sZWZ0ICsgXCIsXCIgKyBtYXJnaW4udG9wICsgXCIpXCIpO1xuXG4gIGZ1bmN0aW9uIGxhc3NvU3RhcnQgKCkge1xuICAgIHBsb3RDbGVhcmVyLmNsZWFyVGFibGUoKTtcbiAgICBjb25zb2xlLmxvZyhsYXNzbylcbiAgICBsYXNzby5pdGVtcygpXG4gICAgICAgICAuYXR0cihcInJcIiwzLjUpIC8vIHJlc2V0IHNpemVcbiAgICAgICAgIC5zdHlsZShcImZpbGxcIixudWxsKSAvLyBjbGVhciBhbGwgb2YgdGhlIGZpbGxzIChncmV5cyBvdXQpXG4gICAgICAgICAuY2xhc3NlZCh7XCJub3RfcG9zc2libGVcIjp0cnVlLFwic2VsZWN0ZWRcIjpmYWxzZX0pOyAvLyBzdHlsZSBhcyBub3QgcG9zc2libGVcbiAgfVxuXG4gIGZ1bmN0aW9uIGxhc3NvRHJhdygpIHtcbiAgICAvLyBTdHlsZSB0aGUgcG9zc2libGUgZG90c1xuICAgIGxhc3NvLml0ZW1zKClcbiAgICAgICAgIC5maWx0ZXIoKGRvdCkgPT4gKCBkb3QucG9zc2libGUgPT09IHRydWUgKSlcbiAgICAgICAgIC5jbGFzc2VkKHsgXCJub3RfcG9zc2libGVcIjogZmFsc2UsIFwicG9zc2libGVcIjogdHJ1ZSB9KTtcblxuICAgIC8vIFN0eWxlIHRoZSBub3QgcG9zc2libGUgZG90XG4gICAgbGFzc28uaXRlbXMoKVxuICAgICAgICAgLmZpbHRlcigoZCkgPT4gKCBkLnBvc3NpYmxlID09PSBmYWxzZSApKVxuICAgICAgICAgLmNsYXNzZWQoe1wibm90X3Bvc3NpYmxlXCI6dHJ1ZSxcInBvc3NpYmxlXCI6ZmFsc2V9KVxuICAgICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIFwiIzAwMFwiKTtcbiAgfTtcblxuXG4gICAgdmFyIGxhc3NvX2VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gUmVzZXQgdGhlIGNvbG9yIG9mIGFsbCBkb3RzXG4gICAgICBsYXNzby5pdGVtcygpXG4gICAgICAuc3R5bGUoXCJmaWxsXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGNvbG9yKGRbY29sb3JfY29sdW1uXSk7IH0pO1xuXG4gICAgICAvLyBTdHlsZSB0aGUgc2VsZWN0ZWQgZG90c1xuICAgICAgbGFzc28uaXRlbXMoKS5maWx0ZXIoZnVuY3Rpb24oZCkge3JldHVybiBkLnNlbGVjdGVkPT09dHJ1ZX0pXG4gICAgICAuY2xhc3NlZCh7XCJub3RfcG9zc2libGVcIjpmYWxzZSxcInBvc3NpYmxlXCI6ZmFsc2V9KVxuICAgICAgLmF0dHIoXCJyXCIsNi41KTtcblxuICAgICAgLy8gZ2V0IHZhbHVlcyBmb3IgdGFibGUgLT4gYXJyYXkgaW5zaWRlIGEgbGlzdFxuICAgICAgdmFyIHpzeCA9IGxhc3NvLml0ZW1zKCkuZmlsdGVyKGZ1bmN0aW9uKGQpIHtyZXR1cm4gZC5zZWxlY3RlZD09PXRydWV9KTtcbiAgICBsZXQgeF92YWx1ZXMgPSBbXTtcbiAgICBsZXQgeV92YWx1ZXMgPSBbXTtcbiAgICAgIC8vIGFkanVzdCB0aGUgeCBhbmQgeSB2YWx1ZXNcbiAgICAgIGZvciAodmFyIGk9MDsgaTx6c3hbMF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgeF92YWx1ZXMucHVzaCgoKCgoenN4WzBdW2ldLmdldEJCb3goKS54KzYuNSkgKiAoeF9tYXggLSB4X21pbikpL3dpZHRoICsgeF9taW4gKSkpO1xuICAgICAgICB5X3ZhbHVlcy5wdXNoKCgoKCh6c3hbMF1baV0uZ2V0QkJveCgpLnkrNi41KSAqICh5X21pbiAtIHlfbWF4KSkvaGVpZ2h0ICsgeV9tYXgpKSk7XG4gICAgICB9XG4gICAgICB2YXIgc2VsZWN0ZWRfZGF0YT1bXSwgc2VsZWN0ZWRfZGF0YV9pbmRpY2VzPVtdO1xuICAgICAgLy8gQ29tcGFyZSBldmVyeSBzZWxlY3RlZCBwb2ludCB0byBhbGwgcG9pbnRzICh0ZW1wWClcbiAgICAgIC8vIGluIG9yZGVyIHRvIG1hdGNoIGNvb3JkaW5hdGVzIHdpdGggYWN0dWFsIGRhdGFcbiAgICAgIGZvciAodmFyIGlpPTA7aWk8eF92YWx1ZXMubGVuZ3RoO2lpKyspIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJsYXNzb19lbmQgZ2F0aGVyaW5nIHNlbGVjdGVkIGRhdGFcIik7XG4gICAgICAgIGNvbnNvbGUubG9nKHRlbXAxLmxlbmd0aCk7XG4gICAgICAgIGZvciAodmFyIGpqPTA7amo8dGVtcDEubGVuZ3RoO2pqKyspIHtcbiAgICAgICAgICB4X3ZhbHVlc1tpaV0gPSArKHhfdmFsdWVzW2lpXS50b0ZpeGVkKDMpKTtcbiAgICAgICAgICB5X3ZhbHVlc1tpaV0gPSArKHlfdmFsdWVzW2lpXS50b0ZpeGVkKDUpKTtcbiAgICAgICAgICBpZiAoICh4X3ZhbHVlc1tpaV0gPT09ICsodGVtcDFbampdLnRvRml4ZWQoMykpKSAmJiAoeV92YWx1ZXNbaWldID09PSArKHRlbXAyW2pqXS50b0ZpeGVkKDUpKSkgKSB7XG4gICAgICAgICAgICBsZXQgYWxsX3ZhbHVlcyA9IHt9O1xuICAgICAgICAgICAgZm9yICh2YXIgaz0xO2s8Y2F0ZWdvcmllcy5sZW5ndGg7aysrKSB7XG4gICAgICAgICAgICAgIGFsbF92YWx1ZXNbY2F0ZWdvcmllc1trXV0gPSAoZGljdDFbY2F0ZWdvcmllc1trXV1bampdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmKHNlYXJjaGRpYyhzZWxlY3RlZF9kYXRhLGFsbF92YWx1ZXMpPT10cnVlKXtcbiAgICAgICAgICAgICAgc2VsZWN0ZWRfZGF0YS5wdXNoKGFsbF92YWx1ZXMpO1xuICAgICAgICAgICAgICBzZWxlY3RlZF9kYXRhX2luZGljZXMucHVzaChqaik7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gcmVuZGVyIHRoZSB0YWJsZSBmb3IgdGhlIHBvaW50cyBzZWxlY3RlZCBieSBsYXNzb1xuICAgICAgaWYgKHNlbGVjdGVkX2RhdGEubGVuZ3RoID4gMCkge1xuICAgICAgICBjb25zb2xlLmxvZyhcIlJlbmRlcmluZyB0YWJsZS4uLlwiKTtcbiAgICAgICAgY29uc29sZS5sb2coc2VsZWN0ZWRfZGF0YSk7XG4gICAgICAgIGNvbnNvbGUubG9nKGNvbHVtbnMpO1xuICAgICAgICBjb25zb2xlLmxvZyh4X3ZhbHVlcyk7XG4gICAgICAgIHZhciBwZW9wbGVUYWJsZSA9IHRhYnVsYXRlKHNlbGVjdGVkX2RhdGEsIGNvbHVtbnMsIHhfdmFsdWVzKTtcbiAgICAgICAgaWYgKFwic2VtYW50aWNfbW9kZWxcIiBpbiBkaWN0cyAmJiBkaWN0c1tcInNlbWFudGljX21vZGVsXCJdID09IFwidHJ1ZVwiKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coXCJQcmVkaWN0aW5nIHdvcmRzLi4uXCIpO1xuICAgICAgICAgIGNsYXNzaWZ5KHNlbGVjdGVkX2RhdGFfaW5kaWNlcywgdmVjdG9yc3BhY2VfMmRhcnJheSwgd2VpZ2h0c18yZGFycmF5LCBiaWFzZXNfMWRhcnJheSwgdm9jYWJfMWRhcnJheSk7XG4gICAgICAgICAgYmVuY2htYXJrKHNlbGVjdGVkX2RhdGFfaW5kaWNlcywgYm93XzJkYXJyYXksIHZvY2FiXzFkYXJyYXkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlc2V0IHRoZSBzdHlsZSBvZiB0aGUgbm90IHNlbGVjdGVkIGRvdHMgKHdlIG1hZGUgdGhlbSAwLjUgc21hbGxlcilcbiAgICAgIGxhc3NvLml0ZW1zKCkuZmlsdGVyKGZ1bmN0aW9uKGQpIHtyZXR1cm4gZC5zZWxlY3RlZD09PWZhbHNlfSlcbiAgICAgIC5jbGFzc2VkKHtcIm5vdF9wb3NzaWJsZVwiOmZhbHNlLFwicG9zc2libGVcIjpmYWxzZX0pXG4gICAgICAuYXR0cihcInJcIiwzKVxuICAgICAgLnN0eWxlKFwic3Ryb2tlXCIsIFwiIzAwMFwiKTtcbiAgICB9O1xuXG4gIC8vIENyZWF0ZSB0aGUgYXJlYSB3aGVyZSB0aGUgbGFzc28gZXZlbnQgY2FuIGJlIHRyaWdnZXJlZFxuICB2YXIgbGFzc29fYXJlYSA9IHN2Zy5hcHBlbmQoXCJyZWN0XCIpXG4gIC5hdHRyKFwid2lkdGhcIix3aWR0aClcbiAgLmF0dHIoXCJoZWlnaHRcIixoZWlnaHQpXG4gIC5zdHlsZShcIm9wYWNpdHlcIiwwKTtcblxuICAvLyBEZWZpbmUgdGhlIGxhc3NvXG4gIHZhciBsYXNzbyA9IGQzLmxhc3NvKClcbiAgICAgIC5jbG9zZVBhdGhEaXN0YW5jZSg3NSkgLy8gbWF4IGRpc3RhbmNlIGZvciB0aGUgbGFzc28gbG9vcCB0byBiZSBjbG9zZWRcbiAgICAgIC5jbG9zZVBhdGhTZWxlY3QodHJ1ZSkgLy8gY2FuIGl0ZW1zIGJlIHNlbGVjdGVkIGJ5IGNsb3NpbmcgdGhlIHBhdGg/XG4gICAgICAuaG92ZXJTZWxlY3QodHJ1ZSkgLy8gY2FuIGl0ZW1zIGJ5IHNlbGVjdGVkIGJ5IGhvdmVyaW5nIG92ZXIgdGhlbT9cbiAgICAgIC5hcmVhKGxhc3NvX2FyZWEpIC8vIGFyZWEgd2hlcmUgdGhlIGxhc3NvIGNhbiBiZSBzdGFydGVkXG4gICAgICBcbiAgbGFzc28ub24oXCJzdGFydFwiLGxhc3NvU3RhcnQpIC8vIGxhc3NvIHN0YXJ0IGZ1bmN0aW9uXG4gICAgICAgLm9uKFwiZHJhd1wiLGxhc3NvRHJhdykgLy8gbGFzc28gZHJhdyBmdW5jdGlvblxuICAgICAgIC5vbihcImVuZFwiLGxhc3NvX2VuZCk7IC8vIGxhc3NvIGVuZCBmdW5jdGlvblxuXG4gIC8vIEluaXQgdGhlIGxhc3NvIG9iamVjdCBvbiB0aGUgc3ZnOmcgdGhhdCBjb250YWlucyB0aGUgZG90c1xuICBzdmcuY2FsbChsYXNzbyk7XG5cbiAgY29uc29sZS5sb2coJ0xvYWRpbmcgbWFpbiBkYXRhLCBhZ2FpbicpIC8vIGxvYWQgZGF0YVxuICBkMy50c3YoZGF0YXNldCwgZnVuY3Rpb24oZXJyb3IsIGRhdGEpIHtcblxuICAgICAgLy8gY2hhbmdlIHN0cmluZyAoZnJvbSBDU1YpIGludG8gbnVtYmVyIGZvcm1hdFxuICAgICAgdmFyIG51bWVyaWNzID0ge30sIHN5bWJvbCA9IHt9O1xuICAgICAgLy9PbWl0dGluZyBTZWxlY3QgKDApXG4gICAgICBmb3IodmFyIGk9MTtpPGNhdGVnb3JpZXMubGVuZ3RoO2krKykge1xuICAgICAgICAgIC8vIGluaXRpYWxpemUgdGhlIHZhbHVlIGZvciBlYWNoIGNhdGVnb3J5IGtleSB0byBlbXB0eSBsaXN0XG4gICAgICAgICAgZGljdDFbY2F0ZWdvcmllc1tpXV0gPSBbXTtcbiAgICAgICAgICAvLyBpbml0aWFsaXplIGFsbCBjYXRlZ29yaWVzIGFzIG51bWVyaWNcbiAgICAgICAgICBudW1lcmljc1tjYXRlZ29yaWVzW2ldXSA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvdW50ZXIgPSAwO1xuICAgICAgICBkYXRhLmZvckVhY2goZnVuY3Rpb24oZCkge1xuICAgICAgICAgIC8vIGNvZXJjZSB0aGUgZGF0YSB0byBudW1iZXJzXG4gICAgICAgICAgZC54ID0gK2QueDtcbiAgICAgICAgICBkW1wieVwiXSA9ICtkW1wieVwiXTtcblxuICAgICAgICAgIGZvcih2YXIgaT0xO2k8Y2F0ZWdvcmllcy5sZW5ndGg7aSsrKXtcbiAgICAgICAgICAgICAgLy8gYWRkIGV2ZXJ5IGF0dHJpYnV0ZSBvZiBwb2ludCB0byB0aGUge2NhdGVnb3J5Olt2YWwxLHZhbDIsLi4uXX1cbiAgICAgICAgICAgICAgZGljdDFbY2F0ZWdvcmllc1tpXV0ucHVzaChkW2NhdGVnb3JpZXNbaV1dKTtcbiAgICAgICAgICAgICAgLy8gcmV2b2tlIGEgY2F0ZWdvcnkncyBudW1lcmljcyBzdGF0dXMgaWYgZmluZCBhbiBlbnRyeSBoYXMgYSBub24tSW50IG9yIG5vbi1udWxsIHZhbHVlIGZvciB0aGF0IGNhdGVnb3J5XG4gICAgICAgICAgICAgIG51bWVyaWNzW2NhdGVnb3JpZXNbaV1dID0gbnVtZXJpY3NbY2F0ZWdvcmllc1tpXV0gJiYgKGRbY2F0ZWdvcmllc1tpXV0gPT0gXCJcIiB8fCBkW2NhdGVnb3JpZXNbaV1dID09IHBhcnNlRmxvYXQoZFtjYXRlZ29yaWVzW2ldXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIC8vIGZpbGwgdGhlIHN5bWJvbCBkaWN0aW9uYXJ5IHdpdGggYWxsIHBvc3NpYmxlIHZhbHVlcyBvZiB0aGUgc2hhcGluZyBjb2x1bW4gYXMga2V5c1xuICAgICAgICAgIC8vIHZhbHVlIGlzIHRoZSBvcmRlciBvZiBwb2ludHNcbiAgICAgICAgICBpZiAoIShkW3NoYXBpbmdfY29sdW1uXSBpbiBzeW1ib2wpKSB7XG4gICAgICAgICAgICBzeW1ib2xbZFtzaGFwaW5nX2NvbHVtbl1dID0gY291bnRlcjtcbiAgICAgICAgICAgIGNvdW50ZXIgPSBjb3VudGVyICsgMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gcHVzaCBhbGwgeCB2YWx1ZXMsIHkgdmFsdWVzLCBhbmQgYWxsIGNhdGVnb3J5IHNlYXJjaCB2YWx1ZXMgaW50byB0ZW1wMS8yLzNcbiAgICAgICAgICB0ZW1wMS5wdXNoKGQueCk7XG4gICAgICAgICAgdGVtcDIucHVzaChkW1wieVwiXSk7XG4gICAgICAgICAgdGVtcDMucHVzaChkW2NhdGVnb3J5X3NlYXJjaF0pO1xuICAgICAgICAvLyBjb25zb2xlLmxvZyhkW1wielwiXSA9PSBwYXJzZUludChkW1wielwiXSkpO1xuICAgICAgfSk7XG4gICAgICAgIGNvbnNvbGUubG9nKG51bWVyaWNzKTtcbiAgICAgICAgY29uc29sZS5sb2coY29sb3JfY29sdW1uKTtcbiAgICAgIC8vIHNldCBjb2xvciBhY2NvcmRpbmcgdG8gc3BlY3RydW1cbiAgICAgIGlmIChudW1lcmljc1tjb2xvcl9jb2x1bW5dICYmIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYm94MScpLmNoZWNrZWQpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3VzaW5nIHNwZWN0cnVtJyk7XG4gICAgICAgICAgLy8gdGFrZSBsb2cgaWYgbG9nIGNoZWNrYm94IGNoZWNrZWRcbiAgICAgICAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Nib3gyJykuY2hlY2tlZCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ3VzaW5nIGxvZycpO1xuICAgICAgICAgICAgbTEgPSAoZDMubWluKGRhdGEubWFwKGZ1bmN0aW9uKGQpIHtyZXR1cm4gTWF0aC5sb2cocGFyc2VGbG9hdChkW2NvbG9yX2NvbHVtbl0pKTsgfSkpKTtcbiAgICAgICAgICAgIG0yID0gKGQzLm1heChkYXRhLm1hcChmdW5jdGlvbihkKSB7cmV0dXJuIE1hdGgubG9nKHBhcnNlRmxvYXQoZFtjb2xvcl9jb2x1bW5dKSk7IH0pKSk7XG4gICAgICAgICAgfSBlbHNle1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ25vdCB1c2luZyBsb2cnKTtcbiAgICAgICAgICAgIG0xID0gKGQzLm1pbihkYXRhLm1hcChmdW5jdGlvbihkKSB7cmV0dXJuIHBhcnNlRmxvYXQoZFtjb2xvcl9jb2x1bW5dKX0pKSk7XG4gICAgICAgICAgICBtMiA9IChkMy5tYXgoZGF0YS5tYXAoZnVuY3Rpb24oZCkge3JldHVybiBwYXJzZUZsb2F0KGRbY29sb3JfY29sdW1uXSl9KSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnNvbGUubG9nKG0xLCBtMik7XG4gICAgICAgICAgbTEgPSBNYXRoLm1heChOdW1iZXIuTUlOX1ZBTFVFLCBtMSk7XG4gICAgICAgICAgY29uc29sZS5sb2cobTEsIG0yKTtcblxuICAgICAgICAgIGNvbG9yID0gZDMuc2NhbGUubGluZWFyKClcbiAgICAgICAgICAuZG9tYWluKGxpbnNwYWNlKG0xLCBtMixzY2FsZS5sZW5ndGgpKVxuICAgICAgICAgICAgLy8uZG9tYWluKGxpbnNwYWNlKGQzLm1pbihkYXRhLm1hcChmdW5jdGlvbihkKSB7cmV0dXJuIHBhcnNlSW50KGRbY29sb3JfY29sdW1uXSl9KSksIGQzLm1heChkYXRhLm1hcChmdW5jdGlvbihkKSB7cmV0dXJuIHBhcnNlSW50KGRbY29sb3JfY29sdW1uXSl9KSksc2NhbGUubGVuZ3RoKSlcbiAgICAgICAgICAgIC5yYW5nZShzY2FsZSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdub3QgdXNpbmcgc3BlY3RydW0nKTtcbiAgICAgICAgICAgIGNvbG9yID0gZDMuc2NhbGUub3JkaW5hbCgpLnJhbmdlKGQzX2NhdGVnb3J5MjBfc2h1ZmZsZWQpO1xuICAgICAgICAgIH1cblxuICAgICAgLy8gZG9uJ3Qgd2FudCBkb3RzIG92ZXJsYXBwaW5nIGF4aXMsIHNvIGFkZCBpbiBidWZmZXIgdG8gZGF0YSBkb21haW5cbiAgICAgIHZhciB6b29tID0gZ2V0UGFyYW1ldGVyQnlOYW1lKCdab29tJyk7IC8vIHVudXNlZCwgY2FwaXRhbGl6ZWQgWiBhbnl3YXkgYXMgY2hhbmdlZCBhYm92ZVxuXG4gICAgICBpZiAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJjYm94M1wiKS5jaGVja2VkPT1mYWxzZSkge1xuICAgICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcInpvb214eVwiKS52YWx1ZSA9IFwiXCI7XG4gICAgICAgIHpvb21lZCA9IDA7XG4gICAgICAgIG5lZWRab29tID0gZmFsc2U7XG4gICAgICAgIHhfbWF4ID0gZDMubWF4KGRhdGEsIHhWYWx1ZSkrMTtcbiAgICAgICAgeF9taW4gPSBkMy5taW4oZGF0YSwgeFZhbHVlKS0xO1xuICAgICAgICB5X21heCA9IGQzLm1heChkYXRhLCB5VmFsdWUpKzE7XG4gICAgICAgIHlfbWluID0gZDMubWluKGRhdGEsIHlWYWx1ZSktMTtcbiAgICAgIH1cblxuICAgICAgLy8gaWYgem9vbSBpcyBjaGVja2VkIGFuZCBjb25kaXRpb25zIGFyZSBzYXRpc2ZpZWRcbiAgICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImNib3gzXCIpLmNoZWNrZWQ9PXRydWUgICYmIG5lZWRab29tID09IHRydWUgJiYgY29vcmRpbmF0ZXN4Lmxlbmd0aCA+PSAyKSB7XG5cbiAgICAgICAgeF9tYXggPSB4U2NhbGUuaW52ZXJ0KE1hdGgubWF4KGNvb3JkaW5hdGVzeFswXSwgY29vcmRpbmF0ZXN4WzFdKSkrMTtcbiAgICAgICAgeF9taW4gPSB4U2NhbGUuaW52ZXJ0KE1hdGgubWluKGNvb3JkaW5hdGVzeFswXSwgY29vcmRpbmF0ZXN4WzFdKSktMTtcbiAgICAgICAgeV9tYXggPSB5U2NhbGUuaW52ZXJ0KE1hdGgubWluKGNvb3JkaW5hdGVzeVswXSwgY29vcmRpbmF0ZXN5WzFdKSkrMTtcbiAgICAgICAgeV9taW4gPSB5U2NhbGUuaW52ZXJ0KE1hdGgubWF4KGNvb3JkaW5hdGVzeVswXSwgY29vcmRpbmF0ZXN5WzFdKSktMTtcblxuICAgICAgICBjb25zb2xlLmxvZyh4X21heCwgeF9taW4sIHlfbWF4LCB5X21pbik7XG4gICAgICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiem9vbXh5XCIpLnZhbHVlID0gXCJYOltcIitwYXJzZUludCh4X21pbikrXCIsIFwiK3BhcnNlSW50KHhfbWF4KStcIl0gWTpbXCIrcGFyc2VJbnQoeV9taW4pK1wiLCBcIitwYXJzZUludCh5X21heCkrXCJdXCI7XG5cbiAgICAgICAgem9vbWVkID0gMTtcbiAgICAgICAgbmVlZFpvb20gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgeFNjYWxlLmRvbWFpbihbeF9taW4sIHhfbWF4XSk7XG4gICAgICAgICAgICAgICAgICAgICAgeVNjYWxlLmRvbWFpbihbeV9taW4sIHlfbWF4XSk7XG5cbiAgICAgIC8vIHgtYXhpc1xuICAgICAgbGV0IGN4ID0gMDtcbiAgICAgIGxldCBjeSA9IDA7XG4gICAgICBsZXQgYW5zID0gMDtcblxuICAgICAgLy8gZHJhdyB0aGUgeC1heGlzIG9mIHBsb3RcbiAgICAgIHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAuYXR0cihcImNsYXNzXCIsIFwieCBheGlzXCIpXG4gICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZSgwLFwiICsgaGVpZ2h0ICsgXCIpXCIpXG4gICAgICAuY2FsbCh4QXhpcylcbiAgICAgIC5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAuYXR0cihcImNsYXNzXCIsIFwibGFiZWxcIilcbiAgICAgIC5hdHRyKFwieFwiLCB3aWR0aClcbiAgICAgIC5hdHRyKFwieVwiLCAtNilcbiAgICAgIC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwiZW5kXCIpXG4gICAgICAudGV4dChcIlwiKTtcblxuICAgICAgLy8gZHJhdyB0aGUgeS1heGlzIG9mIHBsb3RcbiAgICAgIHN2Zy5hcHBlbmQoXCJnXCIpXG4gICAgICAuYXR0cihcImNsYXNzXCIsIFwieSBheGlzXCIpXG4gICAgICAuY2FsbCh5QXhpcylcbiAgICAgIC5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAuYXR0cihcImNsYXNzXCIsIFwibGFiZWxcIilcbiAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwicm90YXRlKC05MClcIilcbiAgICAgIC5hdHRyKFwieVwiLCA2KVxuICAgICAgLmF0dHIoXCJkeVwiLCBcIi43MWVtXCIpXG4gICAgICAuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcImVuZFwiKVxuICAgICAgLnRleHQoXCJcIik7XG5cbiAgICAgIC8vIHRvIGlkZW50aWZ5IHRoZSBjb25kaXRpb24gb2YgdHJhbnNwYXJlbnQgY29sdW1uIHZhbHVlc1xuICAgICAgaWYgKHRyYW5zcGFyZW50X2NvbHVtbiAhPT0gXCJTZWxlY3RcIiAmJiB2YWxfdHJhbnNwICE9PSBcIlwiICYmIHZhbF9vcGFjaXR5Tm9NYXRjaCAhPT0gXCJcIikge1xuICAgICAgICB0cmFuc3BhcmVudF9jb2x1bW4gPSB0cmFuc3BhcmVudF9jb2x1bW4udG9TdHJpbmcoKTtcbiAgICAgICAgICB2YWxfdHJhbnNwID0gdmFsX3RyYW5zcC50b1N0cmluZygpOyAvLyA/PyBubyB0byBsb3dlciBjYXNlIGhlcmU/XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgdmFsX3RyYW5zcCA9IHZhbF90cmFuc3AudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0cmFuc3BhciA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICBpZiAodmFsX3RyYW5zcCAhPT0gXCJcIiAmJiB0eXBlb2YgZCAhPSAndW5kZWZpbmVkJykge1xuICAgICAgICAgIC8vIGlmIHBvaW50J3MgdHJhbnNwIGNvbHVtbiB2YWx1ZSBpcyBlcXVhbCB0byB0aGUgdmFsdWUgc3BlY2lmaWVkLCByZXR1cm4gdmFsX29wYWNpdHlNYXRjaCwgZWxzZSB2YWxfb3BhY2l0eU5vTWF0Y2hcbiAgICAgICAgICB2YXIgbWF0Y2g7XG4gICAgICAgICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYm94NicpLmNoZWNrZWQpIHtcbiAgICAgICAgICAgIG1hdGNoID0gZFt0cmFuc3BhcmVudF9jb2x1bW5dID09IHZhbF90cmFuc3A7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1hdGNoID0gZFt0cmFuc3BhcmVudF9jb2x1bW5dICYmIChkW3RyYW5zcGFyZW50X2NvbHVtbl0udG9Mb3dlckNhc2UoKS5pbmRleE9mKHZhbF90cmFuc3AudG9Mb3dlckNhc2UoKSkgPiAtMSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWxfb3BhY2l0eU1hdGNoKTtcbiAgICAgICAgICB9IGVsc2V7XG4gICAgICAgICAgICByZXR1cm4gcGFyc2VGbG9hdCh2YWxfb3BhY2l0eU5vTWF0Y2gpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgIC8vIHNlYXJjaGluZyBhY2NvcmRpbmcgdG8gdGhlIHN1YnN0cmluZyBnaXZlbiBhbmQgc2VhcmNoaW5nIGNvbHVtblxuICAgICAgdmFyIHNlYXJjaEZ1bmMgPSBmdW5jdGlvbihkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgZFtjYXRlZ29yeV9zZWFyY2hdID09ICd1bmRlZmluZWQnICkge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgICAgLy8gbm9NYXRjaCB0cnV0aHkgaWYgbm90IGZvdW5kXG4gICAgICAgICAgdmFyIG5vTWF0Y2g7XG4gICAgICAgICAgaWYgKGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYm94NScpLmNoZWNrZWQpIHtcbiAgICAgICAgICAgIG5vTWF0Y2ggPSBkW2NhdGVnb3J5X3NlYXJjaF0gIT0gdmFsX3NlYXJjaDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9NYXRjaCA9IGRbY2F0ZWdvcnlfc2VhcmNoXS50b0xvd2VyQ2FzZSgpLmluZGV4T2YodmFsX3NlYXJjaC50b0xvd2VyQ2FzZSgpKSA8IDBcbiAgICAgICAgICAgIHx8IHZhbF9zZWFyY2gubGVuZ3RoID09PSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbm9NYXRjaCA/IDEgOiAyO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBzZWFyY2hGdW5jMSA9IGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICBpZiAodHlwZW9mIGQgPT0gJ3VuZGVmaW5lZCcgKSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gbm9NYXRjaCB0cnVlIGlmIG5vdCBmb3VuZFxuICAgICAgICAgIHZhciBub01hdGNoO1xuICAgICAgICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2JveDUnKS5jaGVja2VkKSB7XG4gICAgICAgICAgICBub01hdGNoID0gZCAhPSB2YWxfc2VhcmNoO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBub01hdGNoID0gZC50b0xvd2VyQ2FzZSgpLmluZGV4T2YodmFsX3NlYXJjaC50b0xvd2VyQ2FzZSgpKSA8IDBcbiAgICAgICAgICAgIHx8IHZhbF9zZWFyY2gubGVuZ3RoID09PSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gbm9NYXRjaCA/IDEgOiAyO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBzZWFyY2hlZF9kYXRhID0gW10sIHNlYXJjaGVkX2RhdGFfaW5kaWNlcyA9IFtdLCBkX3RlbXA7XG4gICAgICAgIC8qIHRlbXAzIGhvbGRzIHRoZSB2YWx1ZSBvZiBldmVyeSBwb2ludCBmb3IgdGhlIHNlYXJjaCBjb2x1bW4gKi9cbiAgICAgICAgZm9yICh2YXIgaT0wO2k8dGVtcDMubGVuZ3RoO2krKykge1xuICAgICAgICAgIC8vIDAgaWYgZm91bmQgdmFsIGluIHRoaXMgcG9pbnQsIDEgaWYgbm90IGZvdW5kXG4gICAgICAgICAgaWYgKCBzZWFyY2hGdW5jMSh0ZW1wM1tpXSktMSApIHtcbiAgICAgICAgICAgIGRfdGVtcCA9IHt9O1xuICAgICAgICAgICAgICAvLyBlbnRlciBhbGwgZGF0YSBpbnRvIGRpY3Rpb25hcnlcbiAgICAgICAgICAgICAgZm9yKHZhciBqPTE7ajxjYXRlZ29yaWVzLmxlbmd0aDtqKyspIHtcbiAgICAgICAgICAgICAgICBkX3RlbXBbY2F0ZWdvcmllc1tqXV0gPSBkaWN0MVtjYXRlZ29yaWVzW2pdXVtpXTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvLyBvbmx5IGFkZCB0byBzZWFyY2hlZF9kYXRhIGlmIG5vdCBhbHJlYWR5IGluXG4gICAgICAgICAgICAgIGlmKHNlYXJjaGRpYyhzZWFyY2hlZF9kYXRhLCBkX3RlbXApID09PSB0cnVlKSB7XG4gICAgICAgICAgICAgICAgc2VhcmNoZWRfZGF0YS5wdXNoKGRfdGVtcCk7XG4gICAgICAgICAgICAgICAgc2VhcmNoZWRfZGF0YV9pbmRpY2VzLnB1c2goaSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAvLyBjcmVhdGUgdGhlIHRhYmxlXG4gICAgICBpZiAoIHZhbF9zZWFyY2ggIT0gXCJcIiAmJiBzZWFyY2hlZF9kYXRhLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHBlb3BsZVRhYmxlMSA9IHRhYnVsYXRlKHNlYXJjaGVkX2RhdGEsIGNvbHVtbnMpO1xuICAgICAgICBpZiAoXCJzZW1hbnRpY19tb2RlbFwiIGluIGRpY3RzICYmIGRpY3RzW1wic2VtYW50aWNfbW9kZWxcIl0gPT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhcIlByZWRpY3Rpbmcgd29yZHMuLi5cIik7XG4gICAgICAgICAgY2xhc3NpZnkoc2VhcmNoZWRfZGF0YV9pbmRpY2VzLCB2ZWN0b3JzcGFjZV8yZGFycmF5LCB3ZWlnaHRzXzJkYXJyYXksIGJpYXNlc18xZGFycmF5LCB2b2NhYl8xZGFycmF5KTtcbiAgICAgICAgICBiZW5jaG1hcmsoc2VhcmNoZWRfZGF0YV9pbmRpY2VzLCBib3dfMmRhcnJheSwgdm9jYWJfMWRhcnJheSk7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIC8vIGRldGVybWluZXMgdGhlIHJvdGF0aW9uIG9mIHN5bWJvbHMgdGhhdCBjYW4gYmUgZG9uZVxuICAgICAgdmFyIHNpemVzID0ge31cbiAgICAgIHNpemVzWzBdID0gW1wiMFwiLCBcIjkwXCIsIFwiMFwiLCBcIjBcIl1cbiAgICAgIHNpemVzWzFdID0gW1wiMFwiLCBcIjQ1XCIsIFwiMFwiLCBcIjBcIl1cbiAgICAgIHNpemVzWzJdID0gW1wiMFwiLCBcIjkwXCIsIFwiMFwiLCBcIjBcIl1cbiAgICAgIHNpemVzWzNdID0gW1wiMFwiLCBcIjQ1XCIsIFwiMFwiLCBcIjBcIl1cbiAgICAgIHNpemVzWzRdID0gW1wiMFwiLCBcIjkwXCIsIFwiMFwiLCBcIjBcIl1cbiAgICAgIHNpemVzWzVdID0gW1wiMFwiLCBcIjBcIiwgXCIwXCIsIFwiMFwiXVxuICAgICAgdmFyIHN5bWJvbHMgPSBbXCJkaWFtb25kXCIsIFwiY3Jvc3NcIiwgXCJ0cmlhbmdsZS11cFwiLCBcInNxdWFyZVwiLCBcInRyaWFuZ2xlLWRvd25cIixcImNpcmNsZVwiXTtcblxuICAgICAgLyoqKiBCRUdJTiBkcmF3aW5nIGRvdHMgKioqL1xuXG4gICAgICAvLyBzaGFwaW5nIG9mIHN5bWJvbHMgYWNjb3JkaW5nIHRvIHRoZSBzaGFwaW5nIGNvbHVtblxuICAgICAgaWYgKHNoYXBpbmdfY29sdW1uICE9PSBcIlNlbGVjdFwiICkge1xuICAgICAgICAvLyBjb2xvcl9jb2x1bW4gPSBzaGFwaW5nX2NvbHVtbjtcbiAgICAgICAgdmFyIHBvaW50cyA9IHN2Zy5zZWxlY3RBbGwoXCIuZG90XCIpXG4gICAgICAgIC5kYXRhKGRhdGEpXG4gICAgICAgIC5lbnRlcigpO1xuXG4gICAgICAgIHBvaW50cy5hcHBlbmQoXCJwYXRoXCIpXG4gICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24oZCl7IHJldHVybiAoc2VhcmNoRnVuYyhkKSA9PSAxKTsgfSlcbiAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcInBvaW50XCIpXG4gICAgICAgICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBcIiMwMDBcIilcbiAgICAgICAgICAgICAgLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIDEpXG4gICAgICAgIC8vIC5hdHRyKFwiZFwiLCBkMy5zdmcuc3ltYm9sKCkudHlwZShmdW5jdGlvbihkKSB7cmV0dXJuIHN5bWJvbHNbc3ltYm9sW2Rbc2hhcGluZ19jb2x1bW5dXSU2XTt9KS5zaXplKCBmdW5jdGlvbihkKSB7cmV0dXJuIHNpemVzW3BhcnNlSW50KHN5bWJvbFtkW3NoYXBpbmdfY29sdW1uXV0vNiklNF07fSkpXG4gICAgICAgIC5hdHRyKFwiZFwiLCBkMy5zdmcuc3ltYm9sKCkudHlwZShmdW5jdGlvbihkKSB7cmV0dXJuIHN5bWJvbHNbc3ltYm9sW2Rbc2hhcGluZ19jb2x1bW5dXSU2XTt9KS5zaXplKGZ1bmN0aW9uKGQpIHtyZXR1cm4gc2VhcmNoRnVuYyhkKS0xID8gMTgwOjMwO30pKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBcInRyYW5zbGF0ZShcIiArIHhNYXAoZCkgKyBcIixcIiArIHlNYXAoZCkgKyBcIikgcm90YXRlKFwiICsgc2l6ZXNbcGFyc2VJbnQoc3ltYm9sW2Rbc2hhcGluZ19jb2x1bW5dXSU2KV1bcGFyc2VJbnQoc3ltYm9sW2Rbc2hhcGluZ19jb2x1bW5dXS82KSU0XSArIFwiKVwiOyB9KVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYm94MicpLmNoZWNrZWQgPyBjb2xvcihjVmFsdWUyKGQpKSA6IGNvbG9yKGNWYWx1ZShkKSk7fSlcbiAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHRyYW5zcGFyKGQpO30pXG5cbiAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICB0b29sdGlwLnRyYW5zaXRpb24oKVxuICAgICAgICAgIC5kdXJhdGlvbigyMDApXG4gICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcbiAgICAgICAgICB0b29sdGlwLmh0bWwoXG4gICAgICAgICAgICBwcmludEFycmF5KGNhdGVnb3J5X3NlYXJjaF9kYXRhLCBkKSlcbiAgICAgICAgICAuc3R5bGUoXCJsZWZ0XCIsIDYwICsgXCJweFwiKVxuICAgICAgICAgIC5zdHlsZShcInRvcFwiLCAzMCArIFwicHhcIik7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICBkMy5zZWxlY3QodGhpcykuYXR0cihcInJcIiwgZnVuY3Rpb24oZCl7IHJldHVybiBzZWFyY2hGdW5jKGQpLTEgPyA3OjMgOyB9KVxuICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gY29sb3IoY1ZhbHVlKGQpKTt9KTtcbiAgICAgICAgICB0b29sdGlwLnRyYW5zaXRpb24oKVxuICAgICAgICAgIC5kdXJhdGlvbig1MDApXG4gICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgIHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgLnRleHQoZFtmZWF0dXJlX2NvbHVtbl0pXG4gICAgICAgICAgLmF0dHIoXCJ4XCIsIChkMy5ldmVudC5wYWdlWC01MCkpXG4gICAgICAgICAgLmF0dHIoXCJ5XCIsIChkMy5ldmVudC5wYWdlWS0zNSkpO1xuICAgICAgICB9KTtcblxuICAgICAgICBwb2ludHMuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGQpeyByZXR1cm4gKHNlYXJjaEZ1bmMoZCkgPT0gMik7IH0pXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJwb2ludFwiKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgXCJ5ZWxsb3dcIilcbiAgICAgICAgLnN0eWxlKFwic3Ryb2tlLXdpZHRoXCIsIDIpXG4gICAgICAgIC8vIC5hdHRyKFwiZFwiLCBkMy5zdmcuc3ltYm9sKCkudHlwZShmdW5jdGlvbihkKSB7cmV0dXJuIHN5bWJvbHNbc3ltYm9sW2Rbc2hhcGluZ19jb2x1bW5dXSU2XTt9KS5zaXplKCBmdW5jdGlvbihkKSB7cmV0dXJuIHNpemVzW3BhcnNlSW50KHN5bWJvbFtkW3NoYXBpbmdfY29sdW1uXV0vNiklNF07fSkpXG4gICAgICAgIC5hdHRyKFwiZFwiLCBkMy5zdmcuc3ltYm9sKCkudHlwZShmdW5jdGlvbihkKSB7cmV0dXJuIHN5bWJvbHNbc3ltYm9sW2Rbc2hhcGluZ19jb2x1bW5dXSU2XTt9KS5zaXplKGZ1bmN0aW9uKGQpIHtyZXR1cm4gc2VhcmNoRnVuYyhkKS0xID8gMTgwOjMwO30pKVxuICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBcInRyYW5zbGF0ZShcIiArIHhNYXAoZCkgKyBcIixcIiArIHlNYXAoZCkgKyBcIikgcm90YXRlKFwiICsgc2l6ZXNbcGFyc2VJbnQoc3ltYm9sW2Rbc2hhcGluZ19jb2x1bW5dXSU2KV1bcGFyc2VJbnQoc3ltYm9sW2Rbc2hhcGluZ19jb2x1bW5dXS82KSU0XSArIFwiKVwiOyB9KVxuICAgICAgICAuc3R5bGUoXCJmaWxsXCIsIGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdjYm94MicpLmNoZWNrZWQgPyBjb2xvcihjVmFsdWUyKGQpKSA6IGNvbG9yKGNWYWx1ZShkKSk7fSlcbiAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLGZ1bmN0aW9uKGQpIHsgcmV0dXJuIHRyYW5zcGFyKGQpO30pXG5cbiAgICAgICAgLm9uKFwibW91c2VvdmVyXCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICB0b29sdGlwLnRyYW5zaXRpb24oKVxuICAgICAgICAgIC5kdXJhdGlvbigyMDApXG4gICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcbiAgICAgICAgICB0b29sdGlwLmh0bWwoXG4gICAgICAgICAgICBwcmludEFycmF5KGNhdGVnb3J5X3NlYXJjaF9kYXRhLCBkKSlcbiAgICAgICAgICAuc3R5bGUoXCJsZWZ0XCIsIDYwICsgXCJweFwiKVxuICAgICAgICAgIC5zdHlsZShcInRvcFwiLCAzMCArIFwicHhcIik7XG4gICAgICAgIH0pXG4gICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICBkMy5zZWxlY3QodGhpcykuYXR0cihcInJcIiwgZnVuY3Rpb24oZCl7IHJldHVybiBzZWFyY2hGdW5jKGQpLTEgPyA3OjMgOyB9KVxuICAgICAgICAgIC5zdHlsZShcImZpbGxcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gY29sb3IoY1ZhbHVlKGQpKTt9KTtcbiAgICAgICAgICB0b29sdGlwLnRyYW5zaXRpb24oKVxuICAgICAgICAgIC5kdXJhdGlvbig1MDApXG4gICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKTtcbiAgICAgICAgfSlcbiAgICAgICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgIHN2Zy5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgLnRleHQoZFtmZWF0dXJlX2NvbHVtbl0pXG4gICAgICAgICAgLmF0dHIoXCJ4XCIsIChkMy5ldmVudC5wYWdlWC01MCkpXG4gICAgICAgICAgLmF0dHIoXCJ5XCIsIChkMy5ldmVudC5wYWdlWS0zNSkpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGRyYXcgZG90c1xuICAgICAgICBsZXQgbWFya2VkID0ge31cbiAgICAgICAgdmFyIHBvaW50cyA9IHN2Zy5zZWxlY3RBbGwoXCIuZG90XCIpXG4gICAgICAgIC5kYXRhKGRhdGEpXG4gICAgICAgIC5lbnRlcigpO1xuXG4gICAgICAgIHBvaW50cy5hcHBlbmQoXCJjaXJjbGVcIilcbiAgICAgICAgLmZpbHRlcihmdW5jdGlvbihkKXsgcmV0dXJuIChzZWFyY2hGdW5jKGQpID09IDEpOyB9KVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwiZG90XCIpXG4gICAgICAgIC5hdHRyKFwiclwiLCAzKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2VcIiwgXCIjMDAwXCIpXG4gICAgICAgIC5zdHlsZShcInN0cm9rZS13aWR0aFwiLCAxKVxuICAgICAgICAuYXR0cihcImN4XCIsIHhNYXApXG4gICAgICAgIC5hdHRyKFwiY3lcIiwgeU1hcClcbiAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBmdW5jdGlvbihkKSB7IHJldHVybiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2JveDInKS5jaGVja2VkID8gY29sb3IoY1ZhbHVlMihkKSkgOiBjb2xvcihjVmFsdWUoZCkpO30pXG4gICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIixmdW5jdGlvbihkKSB7IHJldHVybiB0cmFuc3BhcihkKTt9KVxuXG4gICAgICAgIC5vbihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgdG9vbHRpcC50cmFuc2l0aW9uKClcbiAgICAgICAgICAuZHVyYXRpb24oMjAwKVxuICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG4gICAgICAgICAgdG9vbHRpcC5odG1sKHByaW50QXJyYXkoY2F0ZWdvcnlfc2VhcmNoX2RhdGEsIGQpKVxuICAgICAgICAgIC5zdHlsZShcImxlZnRcIiwgNjAgKyBcInB4XCIpXG4gICAgICAgICAgLnN0eWxlKFwidG9wXCIsIDMwICsgXCJweFwiKTtcbiAgICAgICAgfSlcblxuICAgICAgICAub24oXCJtb3VzZW91dFwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgdG9vbHRpcC50cmFuc2l0aW9uKClcbiAgICAgICAgICAuZHVyYXRpb24oNTAwKVxuICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMCk7XG4gICAgICAgIH0pXG5cbiAgICAgICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgIGlmICghKFtkMy5ldmVudC5wYWdlWCwgZDMuZXZlbnQucGFnZVldIGluIG1hcmtlZCkpIHtcbiAgICAgICAgICAgIG1hcmtlZFtbZDMuZXZlbnQucGFnZVgsIGQzLmV2ZW50LnBhZ2VZXV0gPSB0cnVlO1xuICAgICAgICAgICAgbWFya2VkW1tkMy5ldmVudC5wYWdlWC0xLCBkMy5ldmVudC5wYWdlWS0xXV0gPSB0cnVlO1xuICAgICAgICAgICAgbWFya2VkW1tkMy5ldmVudC5wYWdlWCsxLCBkMy5ldmVudC5wYWdlWSsxXV0gPSB0cnVlO1xuICAgICAgICAgICAgbWFya2VkW1tkMy5ldmVudC5wYWdlWC0xLCBkMy5ldmVudC5wYWdlWSsxXV0gPSB0cnVlO1xuICAgICAgICAgICAgbWFya2VkW1tkMy5ldmVudC5wYWdlWCsxLCBkMy5ldmVudC5wYWdlWS0xXV0gPSB0cnVlO1xuICAgICAgICAgICAgbWFya2VkW1tkMy5ldmVudC5wYWdlWCsyLCBkMy5ldmVudC5wYWdlWS0yXV0gPSB0cnVlO1xuICAgICAgICAgICAgbWFya2VkW1tkMy5ldmVudC5wYWdlWC0yLCBkMy5ldmVudC5wYWdlWS0yXV0gPSB0cnVlO1xuICAgICAgICAgICAgbWFya2VkW1tkMy5ldmVudC5wYWdlWC0yLCBkMy5ldmVudC5wYWdlWSsyXV0gPSB0cnVlO1xuICAgICAgICAgICAgbWFya2VkW1tkMy5ldmVudC5wYWdlWCsyLCBkMy5ldmVudC5wYWdlWSsyXV0gPSB0cnVlO1xuICAgICAgICAgICAgc3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgIC50ZXh0KGRbZmVhdHVyZV9jb2x1bW5dKVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIChkMy5ldmVudC5wYWdlWC01MCkpXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgKGQzLmV2ZW50LnBhZ2VZLTM1KSk7XG4gICAgICAgICAgICAgICAgICAgIC8qXG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXAxLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwidG9vbHRpcDFcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAxKTtcblxuICAgICAgICAgICAgICAgICAgICB0b29sdGlwMS5odG1sKFwiPGI+XCIrZFtmZWF0dXJlX2NvbHVtbl0rXCI8L2I+XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zdHlsZShcImxlZnRcIiwgKGQzLmV2ZW50LnBhZ2VYICsgMTApICsgXCJweFwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuc3R5bGUoXCJ0b3BcIiwgKGQzLmV2ZW50LnBhZ2VZIC0gMTApICsgXCJweFwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgcG9pbnRzLmFwcGVuZChcImNpcmNsZVwiKVxuICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uKGQpeyByZXR1cm4gKHNlYXJjaEZ1bmMoZCkgPT0gMik7IH0pXG4gICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJkb3RcIilcbiAgICAgICAgLmF0dHIoXCJyXCIsIDcpXG4gICAgICAgIC5zdHlsZShcInN0cm9rZVwiLCBcInllbGxvd1wiKVxuICAgICAgICAuc3R5bGUoXCJzdHJva2Utd2lkdGhcIiwgMilcbiAgICAgICAgLmF0dHIoXCJjeFwiLCB4TWFwKVxuICAgICAgICAuYXR0cihcImN5XCIsIHlNYXApXG4gICAgICAgIC5zdHlsZShcImZpbGxcIiwgZnVuY3Rpb24oZCkgeyByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Nib3gyJykuY2hlY2tlZCA/IGNvbG9yKGNWYWx1ZTIoZCkpIDogY29sb3IoY1ZhbHVlKGQpKTt9KVxuICAgICAgICAuc3R5bGUoXCJvcGFjaXR5XCIsZnVuY3Rpb24oZCkgeyByZXR1cm4gdHJhbnNwYXIoZCk7fSlcbiAgICAgICAgICAvLyBqYW5uOiBoZXJlIGlzIHRoZSBtb3VzZW92ZXIgZGlzcGxheVxuICAgICAgICAgIC5vbihcIm1vdXNlb3ZlclwiLCBmdW5jdGlvbihkKSB7XG4gICAgICAgICAgICB0b29sdGlwLnRyYW5zaXRpb24oKVxuICAgICAgICAgICAgLmR1cmF0aW9uKDIwMClcbiAgICAgICAgICAgIC5zdHlsZShcIm9wYWNpdHlcIiwgMSk7XG4gICAgICAgICAgICB0b29sdGlwLmh0bWwoXG4gICAgICAgICAgICAgIHByaW50QXJyYXkoY2F0ZWdvcnlfc2VhcmNoX2RhdGEsIGQpKVxuICAgICAgICAgICAgLnN0eWxlKFwibGVmdFwiLCA2MCArIFwicHhcIilcbiAgICAgICAgICAgIC5zdHlsZShcInRvcFwiLCAzMCArIFwicHhcIik7XG4gICAgICAgICAgfSlcblxuICAgICAgICAgIC5vbihcIm1vdXNlb3V0XCIsIGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgIHRvb2x0aXAudHJhbnNpdGlvbigpXG4gICAgICAgICAgICAuZHVyYXRpb24oNTAwKVxuICAgICAgICAgICAgLnN0eWxlKFwib3BhY2l0eVwiLCAwKTtcbiAgICAgICAgICB9KVxuXG4gICAgICAgICAgLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZCkge1xuICAgICAgICAgICAgaWYgKCEoW2QzLmV2ZW50LnBhZ2VYLCBkMy5ldmVudC5wYWdlWV0gaW4gbWFya2VkKSl7XG4gICAgICAgICAgICAgIG1hcmtlZFtbZDMuZXZlbnQucGFnZVgsIGQzLmV2ZW50LnBhZ2VZXV0gPSB0cnVlO1xuICAgICAgICAgICAgICBtYXJrZWRbW2QzLmV2ZW50LnBhZ2VYLTEsIGQzLmV2ZW50LnBhZ2VZLTFdXSA9IHRydWU7XG4gICAgICAgICAgICAgIG1hcmtlZFtbZDMuZXZlbnQucGFnZVgrMSwgZDMuZXZlbnQucGFnZVkrMV1dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgbWFya2VkW1tkMy5ldmVudC5wYWdlWC0xLCBkMy5ldmVudC5wYWdlWSsxXV0gPSB0cnVlO1xuICAgICAgICAgICAgICBtYXJrZWRbW2QzLmV2ZW50LnBhZ2VYKzEsIGQzLmV2ZW50LnBhZ2VZLTFdXSA9IHRydWU7XG4gICAgICAgICAgICAgIG1hcmtlZFtbZDMuZXZlbnQucGFnZVgrMiwgZDMuZXZlbnQucGFnZVktMl1dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgbWFya2VkW1tkMy5ldmVudC5wYWdlWC0yLCBkMy5ldmVudC5wYWdlWS0yXV0gPSB0cnVlO1xuICAgICAgICAgICAgICBtYXJrZWRbW2QzLmV2ZW50LnBhZ2VYLTIsIGQzLmV2ZW50LnBhZ2VZKzJdXSA9IHRydWU7XG4gICAgICAgICAgICAgIG1hcmtlZFtbZDMuZXZlbnQucGFnZVgrMiwgZDMuZXZlbnQucGFnZVkrMl1dID0gdHJ1ZTtcbiAgICAgICAgICAgICAgc3ZnLmFwcGVuZChcInRleHRcIilcbiAgICAgICAgICAgICAgLnRleHQoZFtmZWF0dXJlX2NvbHVtbl0pXG4gICAgICAgICAgICAgIC5hdHRyKFwieFwiLCAoZDMuZXZlbnQucGFnZVgtNTApKVxuICAgICAgICAgICAgICAuYXR0cihcInlcIiwgKGQzLmV2ZW50LnBhZ2VZLTM1KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLyoqKiBFTkQgZHJhd2luZyBkb3RzICoqKi9cblxuICAgICAgLy8gdGhlIGV2ZW50IHRvIGNhbGwgb24gY2xpY2sgZXZlbnRcbiAgICAgIHN2Zy5vbihcImNsaWNrXCIsZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIHN2Zy5zZWxlY3QoXCIjbXlUZXh0XCIpLnJlbW92ZSgpO1xuXG4gICAgICAgIHRvb2x0aXAxLnN0eWxlKFwib3BhY2l0eVwiLCAwKTtcbiAgICAgICAgdmFyIGNvb3JkaW5hdGVzMSA9IGQzLm1vdXNlKHRoaXMpO1xuICAgICAgICBjb29yZGluYXRlc3gudW5zaGlmdChjb29yZGluYXRlczFbMF0pO1xuICAgICAgICBjb29yZGluYXRlc3kudW5zaGlmdChjb29yZGluYXRlczFbMV0pO1xuICAgICAgICBjb25zb2xlLmxvZyhjb29yZGluYXRlc3gsIGNvb3JkaW5hdGVzeSk7XG4gICAgICB9KVxuXG4gICAgICAvKiBjYW4gbW92ZSB1cCBpbnRvIHRoZSBpZi9lbHNlLCBidXQgbW9yZSBjbGVhciB0byBzZXBhcmF0ZSBmdW5jdGlvbmFsaXR5ICovXG4gICAgICBpZiAoc2hhcGluZ19jb2x1bW4gIT09IFwiU2VsZWN0XCIgKSB7XG4gICAgICAgIGxhc3NvLml0ZW1zKGQzLnNlbGVjdEFsbChcIi5kb3RcIikpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFzc28uaXRlbXMoZDMuc2VsZWN0QWxsKFwiLmRvdFwiKSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBsZW4gPSBjb2xvci5kb21haW4oKS5sZW5ndGg7XG4gICAgICAvLyBpZiBzcGVjdHJ1bVxuICAgICAgaWYgKG51bWVyaWNzW2NvbG9yX2NvbHVtbl0gJiYgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ2Nib3gxJykuY2hlY2tlZCkge1xuXG4gICAgICAgIGlmIChkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnY2JveDInKS5jaGVja2VkKSB7XG4gICAgICAgICAgbTEgPSAoZDMubWluKGRhdGEubWFwKGZ1bmN0aW9uKGQpIHtyZXR1cm4gTWF0aC5sb2cocGFyc2VGbG9hdChkW2NvbG9yX2NvbHVtbl0pKTsgfSkpKTtcbiAgICAgICAgICBtMiA9IChkMy5tYXgoZGF0YS5tYXAoZnVuY3Rpb24oZCkge3JldHVybiBNYXRoLmxvZyhwYXJzZUZsb2F0KGRbY29sb3JfY29sdW1uXSkpOyB9KSkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG0xID0gKGQzLm1pbihkYXRhLm1hcChmdW5jdGlvbihkKSB7cmV0dXJuIHBhcnNlRmxvYXQoZFtjb2xvcl9jb2x1bW5dKX0pKSk7XG4gICAgICAgICAgbTIgPSAoZDMubWF4KGRhdGEubWFwKGZ1bmN0aW9uKGQpIHtyZXR1cm4gcGFyc2VGbG9hdChkW2NvbG9yX2NvbHVtbl0pfSkpKTtcblxuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nKG0xLCBtMik7XG4gICAgICAgIG0xID0gTWF0aC5tYXgoTnVtYmVyLk1JTl9WQUxVRSwgbTEpO1xuICAgICAgICBjb25zb2xlLmxvZyhtMSwgbTIpO1xuXG4gICAgICAgIHZhciBsZWdlbmQgPSBzdmcuc2VsZWN0QWxsKFwiLmxlZ2VuZFwiKVxuICAgICAgICAuZGF0YShjb2xvci5kb21haW4oKSlcbiAgICAgICAgLmVudGVyKCkuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwibGVnZW5kXCIpO1xuXG4gICAgICAgIHZhciBncmFkaWVudCA9IGxlZ2VuZC5hcHBlbmQoJ2RlZnMnKVxuICAgICAgICAuYXBwZW5kKCdsaW5lYXJHcmFkaWVudCcpXG4gICAgICAgIC5hdHRyKCdpZCcsICdncmFkaWVudCcpXG4gICAgICAgICAgICAgICAgICAuYXR0cigneDEnLCAnMCUnKSAvLyBib3R0b21cbiAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsICcxMDAlJylcbiAgICAgICAgICAgICAgICAgIC5hdHRyKCd4MicsICcwJScpIC8vIHRvIHRvcFxuICAgICAgICAgICAgICAgICAgLmF0dHIoJ3kyJywgJzAlJylcbiAgICAgICAgICAgICAgICAgIC5hdHRyKCdzcHJlYWRNZXRob2QnLCAncGFkJyk7XG5cbiAgICAgICAgICAgICAgICAgIHZhciBwY3QgPSBsaW5zcGFjZSgwLCAxMDAsIHNjYWxlLmxlbmd0aCkubWFwKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIE1hdGgucm91bmQoZCkgKyAnJSc7XG4gICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgdmFyIGNvbG91clBjdCA9IGQzLnppcChwY3QsIHNjYWxlKTtcbiAgICAgICAgICAgICAgICAgIGNvbG91clBjdC5mb3JFYWNoKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgZ3JhZGllbnQuYXBwZW5kKCdzdG9wJylcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ29mZnNldCcsIGRbMF0pXG4gICAgICAgICAgICAgICAgICAgIC5hdHRyKCdzdG9wLWNvbG9yJywgZFsxXSlcbiAgICAgICAgICAgICAgICAgICAgLmF0dHIoJ3N0b3Atb3BhY2l0eScsIDEpO1xuICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgIGxlZ2VuZC5hcHBlbmQoJ3JlY3QnKVxuICAgICAgICAgICAgICAgICAgLmF0dHIoJ3gxJywgMClcbiAgICAgICAgICAgICAgICAgIC5hdHRyKCd5MScsIDApXG4gICAgICAgICAgICAgICAgICAuYXR0cignd2lkdGgnLCAxOClcbiAgICAgICAgICAgICAgICAgIC5hdHRyKCdoZWlnaHQnLCAxNTApXG4gICAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInRyYW5zbGF0ZShcIiArIDU4MiArIFwiLCAwKVwiKVxuICAgICAgICAgICAgICAgICAgLnN0eWxlKCdmaWxsJywgJ3VybCgjZ3JhZGllbnQpJyk7XG5cbiAgICAgICAgICAgICAgICAgIHZhciBsZWdlbmRTY2FsZSA9IGQzLnNjYWxlLmxpbmVhcigpXG4gICAgICAgICAgICAgICAgICAuZG9tYWluKFttMSwgbTJdKVxuICAgICAgICAgICAgICAgICAgLnJhbmdlKFsxNTAsIDBdKTtcblxuICAgICAgICAgICAgICAgICAgdmFyIGxlZ2VuZEF4aXMgPSBkMy5zdmcuYXhpcygpXG4gICAgICAgICAgICAgICAgICAuc2NhbGUobGVnZW5kU2NhbGUpXG4gICAgICAgICAgICAgICAgICAub3JpZW50KFwicmlnaHRcIilcbiAgICAgICAgICAgICAgLy8gLnRpY2tWYWx1ZXMoW20xLCBtMl0pXG4gICAgICAgICAgICAgIC50aWNrcygxMCk7XG5cbiAgICAgICAgICAgICAgbGVnZW5kLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImxlZ2VuZCBheGlzXCIpXG4gICAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKFwiICsgNjAwICsgXCIsIDApXCIpXG4gICAgICAgICAgICAgIC5jYWxsKGxlZ2VuZEF4aXMpO1xuICAgICAgfSBlbHNlIHsgLy8gbm8gc3BlY3RydW1cbiAgICAgICAgY29uc29sZS5sb2coT2JqZWN0KTtcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhzeW1ib2wpO1xuICAgICAgICBsZXQgbGVuZyA9IGtleXMubGVuZ3RoO1xuICAgICAgICBpZiAobGVuZzwyMCAmJiBzaGFwaW5nX2NvbHVtbiAhPSBcIlNlbGVjdFwiKSB7XG4gICAgICAgICAgICAvLyBkcmF3IGxlZ2VuZFxuICAgICAgICAgICAgICAvLyA/PyBOb3Qgc3VyZSB3aHksIGJ1dCB0aGlzIGxlZ2VuZCBhcHBlYXJzIG5vdCB0byBzaG93XG4gICAgICAgICAgICAgIHZhciBsZWdlbmQgPSBzdmcuc2VsZWN0QWxsKFwiLmxlZ2VuZFwiKVxuICAgICAgICAgICAgICAuZGF0YShrZXlzKVxuICAgICAgICAgICAgICAuZW50ZXIoKS5hcHBlbmQoXCJnXCIpO1xuICAgICAgICAgICAgICAgICAgLy8gLmF0dHIoXCJjbGFzc1wiLCBcImxlZ2VuZFwiKTtcbiAgICAgICAgICAgICAgICAgIC8vIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQsIGkpIHsgcmV0dXJuIFwidHJhbnNsYXRlKDMwLFwiICsgaSAqIDIwICsgXCIpXCI7IH0pO1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coa2V5cyk7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhzaGFwaW5nX2NvbHVtbik7XG4gICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhzeW1ib2wpO1xuICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coc3ltYm9scyk7XG4gICAgICAgICAgICAgIC8vIGRyYXcgbGVnZW5kIGNvbG9yZWQgcmVjdGFuZ2xlc1xuICAgICAgICAgICAgICBsZWdlbmQuYXBwZW5kKFwicGF0aFwiKVxuICAgICAgICAgICAgICAgICAgLy8gLmF0dHIoXCJkXCIsIGQzLnN2Zy5zeW1ib2woKS50eXBlKGZ1bmN0aW9uKGQpIHtyZXR1cm4gc3ltYm9sc1tzeW1ib2xbZF0lNl07fSkuc2l6ZShmdW5jdGlvbihkKSB7cmV0dXJuIHNpemVzW3BhcnNlSW50KHN5bWJvbFtkXS82KSUzXTt9KSlcbiAgICAgICAgICAgICAgICAgIC5hdHRyKFwiZFwiLCBkMy5zdmcuc3ltYm9sKCkudHlwZShmdW5jdGlvbihkKSB7cmV0dXJuIHN5bWJvbHNbc3ltYm9sW2RdJTZdO30pKVxuICAgICAgICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIHdpZHRoICsgMClcbiAgICAgICAgICAgICAgICAgIC5hdHRyKFwid2lkdGhcIiwgMTgpXG4gICAgICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCAxOClcbiAgICAgICAgICAgICAgICAgIC8vIC5hdHRyKFwidHJhbnNmb3JtXCIsIGZ1bmN0aW9uKGQsIGkpIHsgcmV0dXJuIFwidHJhbnNsYXRlKFwiICsgMjAgKyBcIixcIiArIGkqMjAgKyBcIilcIjsgfSk7XG4gICAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkLCBpKSB7IHJldHVybiBcInRyYW5zbGF0ZShcIiArIDIwICsgXCIsXCIgKyBpKjIwICsgXCIpIHJvdGF0ZShcIiArIHNpemVzW3BhcnNlSW50KHN5bWJvbFtkXSU2KV1bcGFyc2VJbnQoc3ltYm9sW2RdLzYpJTRdICsgXCIpXCI7IH0pO1xuICAgICAgICAgICAgICAvLyBkcmF3IGxlZ2VuZCB0ZXh0XG4gICAgICAgICAgICAgIGxlZ2VuZC5hcHBlbmQoXCJ0ZXh0XCIpXG4gICAgICAgICAgICAgICAgICAvLyAuYXR0cihcInhcIiwgMTAwICsgMClcbiAgICAgICAgICAgICAgICAgIC8vIC5hdHRyKFwieVwiLCA0KVxuICAgICAgICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCBcIi4zNWVtXCIpXG4gICAgICAgICAgICAgICAgICAuc3R5bGUoXCJ0ZXh0LWFuY2hvclwiLCBcImJlZ2luXCIpXG4gICAgICAgICAgICAgICAgICAudGV4dChmdW5jdGlvbihkKSB7IHJldHVybiBkO30pXG4gICAgICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkLCBpKSB7IHJldHVybiBcInRyYW5zbGF0ZSgzMCxcIiArIGkgKiAyMCArIFwiKVwiOyB9KTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZihsZW4gPD0gMzAgJiYgY29sb3JfY29sdW1uICE9IFwiU2VsZWN0XCIpIHtcblxuICAgICAgICAgICAgICAvLyBkcmF3IGxlZ2VuZFxuICAgICAgICAgICAgICB2YXIgbGVnZW5kID0gc3ZnLnNlbGVjdEFsbChcIi5sZWdlbmRcIilcbiAgICAgICAgICAgICAgLmRhdGEoY29sb3IuZG9tYWluKCkpXG4gICAgICAgICAgICAgIC5lbnRlcigpLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImxlZ2VuZFwiKVxuICAgICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBmdW5jdGlvbihkLCBpKSB7IHJldHVybiBcInRyYW5zbGF0ZSgwLFwiICsgaSAqIDIwICsgXCIpXCI7IH0pO1xuXG4gICAgICAgICAgICAgIC8vIGRyYXcgbGVnZW5kIGNvbG9yZWQgcmVjdGFuZ2xlc1xuICAgICAgICAgICAgICBsZWdlbmQuYXBwZW5kKFwicmVjdFwiKVxuICAgICAgICAgICAgICAuYXR0cihcInhcIiwgd2lkdGggKyA2KVxuICAgICAgICAgICAgICAuYXR0cihcIndpZHRoXCIsIDE4KVxuICAgICAgICAgICAgICAuYXR0cihcImhlaWdodFwiLCAxOClcbiAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBjb2xvcik7XG5cbiAgICAgICAgICAgICAgLy8gZHJhdyBsZWdlbmQgdGV4dFxuICAgICAgICAgICAgICBsZWdlbmQuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgICAuYXR0cihcInhcIiwgd2lkdGggKyAwKVxuICAgICAgICAgICAgICAuYXR0cihcInlcIiwgOSlcbiAgICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCBcIi4zNWVtXCIpXG4gICAgICAgICAgICAgIC5zdHlsZShcInRleHQtYW5jaG9yXCIsIFwiZW5kXCIpXG4gICAgICAgICAgICAgIC50ZXh0KGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQ7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgfSk7IC8vIGVuZCBsb2FkIGRhdGFcbn0gLy8gZW5kIGhpZ2hsaWdodGluZyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBYUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./src/modules/highlighting.js\n");

/***/ }),

/***/ "./src/modules/table_creator.js":
/*!**************************************!*\
  !*** ./src/modules/table_creator.js ***!
  \**************************************/
/*! exports provided: classify, benchmark, tabulate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"classify\", function() { return classify; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"benchmark\", function() { return benchmark; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tabulate\", function() { return tabulate; });\n// Create Table functionality -- \n// Utility function used for predicting words in semantic setting\n// Source: https://stackoverflow.com/a/11792230/7100714\nfunction findIndicesOfMax(inp, count) {\n  let outp = new Array();\n  for (let i = 0; i < inp.length; i++) {\n    outp.push(i);\n    if (outp.length > count) {\n      outp.sort((a, b) => (inp[b] - inp[a]));\n      outp.pop();\n    }\n  }\n  return outp;\n}\n\nfunction classify (indices, vs_source, weights_source, biases_source, vocab_source) {\n  let sum_vectors = vs_source[indices[0]];\n  for (i=1; i < indices.length; i++) {\n    sum_vectors = math.add(sum_vectors, vs_source[indices[i]]);\n  }\n  let avg_vector = sum_vectors.map((x) =>  ( x / indices.length ));\n  let mul = math.multiply(avg_vector, weights_source);\n  let add = math.add(mul, biases_source);\n  // get indices of 10 greatest elements\n  let topIndices = findIndicesOfMax(add, 10);\n  console.log(\"Top predicted vocab words:\");\n  let strbuilder = \"Predicted words:\";\n  for (i=0; i<10; i++) {\n    console.log((i+1) + \": \" + vocab_source[topIndices[i]]);\n    strbuilder += \" \" + vocab_source[topIndices[i]] + \",\";\n  }\n  document.getElementById(\"predicted_words\").innerHTML = strbuilder.slice(0, -1);\n};\n\nfunction benchmark (indices, bow_source, vocab_source) { // may need to adjust\n  var num_indices = indices.length;\n  var vocab_freq = bow_source[indices[0]];\n  for (i=1; i < num_indices; i++) {\n    vocab_freq = math.add(vocab_freq, bow_source[indices[i]]);\n  }\n  // get indices of 10 greatest elements\n  var topIndices = findIndicesOfMax(vocab_freq, 10);\n  console.log(\"Most frequent words:\");\n  var strbuilder = \"Most frequent words:\";\n  for (i=0; i<10; i++) {\n    console.log((i+1) + \": \" + vocab_source[topIndices[i]]);\n    strbuilder += \" \" + vocab_source[topIndices[i]] + \",\";\n  }\n  document.getElementById(\"frequent_words\").innerHTML = strbuilder.slice(0, -1);\n};\n\n// displays the summary in tabular form\nfunction tabulate (data_tab, columns) {\n  let table = d3.select(\"body\").append(\"table\").attr(\"class\", \"select3\"),\n      thead = table.append(\"thead\"),\n      tbody = table.append(\"tbody\");\n\n  // append the header row\n  thead.append(\"tr\")\n       .selectAll(\"th\")\n       .data(columns)\n       .enter()\n       .append(\"th\")\n       .text((column) => (column ));\n\n  // create a row for each object in the data\n  let rows = tbody.selectAll(\"tr\")\n                  .data(data_tab)\n                  .enter()\n                  .append(\"tr\");\n\n  // create a cell in each row for each column\n  let cells = rows.selectAll(\"td\")\n                  .data(function(row) {\n                    return columns.map(function(column) {\n                      return {column: column, value: row[column]};\n                    });\n                  })\n                  .enter()\n                  .append(\"td\")\n                  .attr(\"style\", \"font-family: Courier\") // sets the font style\n                  .html((d) => ( d.value ) );\n\n  /*\n    crossfilter dimensions and group by\n    http://animateddata.co.uk/articles/crossfilter/\n  */\n  let output = \"\";\n  let cf = crossfilter(data_tab);\n  /* crossfilter currently only supports up to 32 columns) */\n  for (var i=0;i<columns.length && i<32;i++) {\n    let byParty = cf.dimension((party) => ( party[columns[i]] ));\n    output = output + \"<b>\" + columns[i] + \"</b>\" + \"<br>\";\n    var groupByParty = byParty.group();\n    groupByParty.top(5).forEach(function(p, i) {\n      output = output + p.key + \": \" + p.value + \"<br>\";\n      console.log(p.key + \": \" + p.value);\n    });\n    output = output + \"<br>\";\n  }\n  // side table\n  document.getElementById(\"demo3\").innerHTML = output;\n  return table;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbW9kdWxlcy90YWJsZV9jcmVhdG9yLmpzLmpzIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vLy4vc3JjL21vZHVsZXMvdGFibGVfY3JlYXRvci5qcz85ZTQ5Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIENyZWF0ZSBUYWJsZSBmdW5jdGlvbmFsaXR5IC0tIFxuLy8gVXRpbGl0eSBmdW5jdGlvbiB1c2VkIGZvciBwcmVkaWN0aW5nIHdvcmRzIGluIHNlbWFudGljIHNldHRpbmdcbi8vIFNvdXJjZTogaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzExNzkyMjMwLzcxMDA3MTRcbmZ1bmN0aW9uIGZpbmRJbmRpY2VzT2ZNYXgoaW5wLCBjb3VudCkge1xuICBsZXQgb3V0cCA9IG5ldyBBcnJheSgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGlucC5sZW5ndGg7IGkrKykge1xuICAgIG91dHAucHVzaChpKTtcbiAgICBpZiAob3V0cC5sZW5ndGggPiBjb3VudCkge1xuICAgICAgb3V0cC5zb3J0KChhLCBiKSA9PiAoaW5wW2JdIC0gaW5wW2FdKSk7XG4gICAgICBvdXRwLnBvcCgpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3V0cDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNsYXNzaWZ5IChpbmRpY2VzLCB2c19zb3VyY2UsIHdlaWdodHNfc291cmNlLCBiaWFzZXNfc291cmNlLCB2b2NhYl9zb3VyY2UpIHtcbiAgbGV0IHN1bV92ZWN0b3JzID0gdnNfc291cmNlW2luZGljZXNbMF1dO1xuICBmb3IgKGk9MTsgaSA8IGluZGljZXMubGVuZ3RoOyBpKyspIHtcbiAgICBzdW1fdmVjdG9ycyA9IG1hdGguYWRkKHN1bV92ZWN0b3JzLCB2c19zb3VyY2VbaW5kaWNlc1tpXV0pO1xuICB9XG4gIGxldCBhdmdfdmVjdG9yID0gc3VtX3ZlY3RvcnMubWFwKCh4KSA9PiAgKCB4IC8gaW5kaWNlcy5sZW5ndGggKSk7XG4gIGxldCBtdWwgPSBtYXRoLm11bHRpcGx5KGF2Z192ZWN0b3IsIHdlaWdodHNfc291cmNlKTtcbiAgbGV0IGFkZCA9IG1hdGguYWRkKG11bCwgYmlhc2VzX3NvdXJjZSk7XG4gIC8vIGdldCBpbmRpY2VzIG9mIDEwIGdyZWF0ZXN0IGVsZW1lbnRzXG4gIGxldCB0b3BJbmRpY2VzID0gZmluZEluZGljZXNPZk1heChhZGQsIDEwKTtcbiAgY29uc29sZS5sb2coXCJUb3AgcHJlZGljdGVkIHZvY2FiIHdvcmRzOlwiKTtcbiAgbGV0IHN0cmJ1aWxkZXIgPSBcIlByZWRpY3RlZCB3b3JkczpcIjtcbiAgZm9yIChpPTA7IGk8MTA7IGkrKykge1xuICAgIGNvbnNvbGUubG9nKChpKzEpICsgXCI6IFwiICsgdm9jYWJfc291cmNlW3RvcEluZGljZXNbaV1dKTtcbiAgICBzdHJidWlsZGVyICs9IFwiIFwiICsgdm9jYWJfc291cmNlW3RvcEluZGljZXNbaV1dICsgXCIsXCI7XG4gIH1cbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJwcmVkaWN0ZWRfd29yZHNcIikuaW5uZXJIVE1MID0gc3RyYnVpbGRlci5zbGljZSgwLCAtMSk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gYmVuY2htYXJrIChpbmRpY2VzLCBib3dfc291cmNlLCB2b2NhYl9zb3VyY2UpIHsgLy8gbWF5IG5lZWQgdG8gYWRqdXN0XG4gIHZhciBudW1faW5kaWNlcyA9IGluZGljZXMubGVuZ3RoO1xuICB2YXIgdm9jYWJfZnJlcSA9IGJvd19zb3VyY2VbaW5kaWNlc1swXV07XG4gIGZvciAoaT0xOyBpIDwgbnVtX2luZGljZXM7IGkrKykge1xuICAgIHZvY2FiX2ZyZXEgPSBtYXRoLmFkZCh2b2NhYl9mcmVxLCBib3dfc291cmNlW2luZGljZXNbaV1dKTtcbiAgfVxuICAvLyBnZXQgaW5kaWNlcyBvZiAxMCBncmVhdGVzdCBlbGVtZW50c1xuICB2YXIgdG9wSW5kaWNlcyA9IGZpbmRJbmRpY2VzT2ZNYXgodm9jYWJfZnJlcSwgMTApO1xuICBjb25zb2xlLmxvZyhcIk1vc3QgZnJlcXVlbnQgd29yZHM6XCIpO1xuICB2YXIgc3RyYnVpbGRlciA9IFwiTW9zdCBmcmVxdWVudCB3b3JkczpcIjtcbiAgZm9yIChpPTA7IGk8MTA7IGkrKykge1xuICAgIGNvbnNvbGUubG9nKChpKzEpICsgXCI6IFwiICsgdm9jYWJfc291cmNlW3RvcEluZGljZXNbaV1dKTtcbiAgICBzdHJidWlsZGVyICs9IFwiIFwiICsgdm9jYWJfc291cmNlW3RvcEluZGljZXNbaV1dICsgXCIsXCI7XG4gIH1cbiAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmcmVxdWVudF93b3Jkc1wiKS5pbm5lckhUTUwgPSBzdHJidWlsZGVyLnNsaWNlKDAsIC0xKTtcbn07XG5cbi8vIGRpc3BsYXlzIHRoZSBzdW1tYXJ5IGluIHRhYnVsYXIgZm9ybVxuZXhwb3J0IGZ1bmN0aW9uIHRhYnVsYXRlIChkYXRhX3RhYiwgY29sdW1ucykge1xuICBsZXQgdGFibGUgPSBkMy5zZWxlY3QoXCJib2R5XCIpLmFwcGVuZChcInRhYmxlXCIpLmF0dHIoXCJjbGFzc1wiLCBcInNlbGVjdDNcIiksXG4gICAgICB0aGVhZCA9IHRhYmxlLmFwcGVuZChcInRoZWFkXCIpLFxuICAgICAgdGJvZHkgPSB0YWJsZS5hcHBlbmQoXCJ0Ym9keVwiKTtcblxuICAvLyBhcHBlbmQgdGhlIGhlYWRlciByb3dcbiAgdGhlYWQuYXBwZW5kKFwidHJcIilcbiAgICAgICAuc2VsZWN0QWxsKFwidGhcIilcbiAgICAgICAuZGF0YShjb2x1bW5zKVxuICAgICAgIC5lbnRlcigpXG4gICAgICAgLmFwcGVuZChcInRoXCIpXG4gICAgICAgLnRleHQoKGNvbHVtbikgPT4gKGNvbHVtbiApKTtcblxuICAvLyBjcmVhdGUgYSByb3cgZm9yIGVhY2ggb2JqZWN0IGluIHRoZSBkYXRhXG4gIGxldCByb3dzID0gdGJvZHkuc2VsZWN0QWxsKFwidHJcIilcbiAgICAgICAgICAgICAgICAgIC5kYXRhKGRhdGFfdGFiKVxuICAgICAgICAgICAgICAgICAgLmVudGVyKClcbiAgICAgICAgICAgICAgICAgIC5hcHBlbmQoXCJ0clwiKTtcblxuICAvLyBjcmVhdGUgYSBjZWxsIGluIGVhY2ggcm93IGZvciBlYWNoIGNvbHVtblxuICBsZXQgY2VsbHMgPSByb3dzLnNlbGVjdEFsbChcInRkXCIpXG4gICAgICAgICAgICAgICAgICAuZGF0YShmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbHVtbnMubWFwKGZ1bmN0aW9uKGNvbHVtbikge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7Y29sdW1uOiBjb2x1bW4sIHZhbHVlOiByb3dbY29sdW1uXX07XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgIC5lbnRlcigpXG4gICAgICAgICAgICAgICAgICAuYXBwZW5kKFwidGRcIilcbiAgICAgICAgICAgICAgICAgIC5hdHRyKFwic3R5bGVcIiwgXCJmb250LWZhbWlseTogQ291cmllclwiKSAvLyBzZXRzIHRoZSBmb250IHN0eWxlXG4gICAgICAgICAgICAgICAgICAuaHRtbCgoZCkgPT4gKCBkLnZhbHVlICkgKTtcblxuICAvKlxuICAgIGNyb3NzZmlsdGVyIGRpbWVuc2lvbnMgYW5kIGdyb3VwIGJ5XG4gICAgaHR0cDovL2FuaW1hdGVkZGF0YS5jby51ay9hcnRpY2xlcy9jcm9zc2ZpbHRlci9cbiAgKi9cbiAgbGV0IG91dHB1dCA9IFwiXCI7XG4gIGxldCBjZiA9IGNyb3NzZmlsdGVyKGRhdGFfdGFiKTtcbiAgLyogY3Jvc3NmaWx0ZXIgY3VycmVudGx5IG9ubHkgc3VwcG9ydHMgdXAgdG8gMzIgY29sdW1ucykgKi9cbiAgZm9yICh2YXIgaT0wO2k8Y29sdW1ucy5sZW5ndGggJiYgaTwzMjtpKyspIHtcbiAgICBsZXQgYnlQYXJ0eSA9IGNmLmRpbWVuc2lvbigocGFydHkpID0+ICggcGFydHlbY29sdW1uc1tpXV0gKSk7XG4gICAgb3V0cHV0ID0gb3V0cHV0ICsgXCI8Yj5cIiArIGNvbHVtbnNbaV0gKyBcIjwvYj5cIiArIFwiPGJyPlwiO1xuICAgIHZhciBncm91cEJ5UGFydHkgPSBieVBhcnR5Lmdyb3VwKCk7XG4gICAgZ3JvdXBCeVBhcnR5LnRvcCg1KS5mb3JFYWNoKGZ1bmN0aW9uKHAsIGkpIHtcbiAgICAgIG91dHB1dCA9IG91dHB1dCArIHAua2V5ICsgXCI6IFwiICsgcC52YWx1ZSArIFwiPGJyPlwiO1xuICAgICAgY29uc29sZS5sb2cocC5rZXkgKyBcIjogXCIgKyBwLnZhbHVlKTtcbiAgICB9KTtcbiAgICBvdXRwdXQgPSBvdXRwdXQgKyBcIjxicj5cIjtcbiAgfVxuICAvLyBzaWRlIHRhYmxlXG4gIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwiZGVtbzNcIikuaW5uZXJIVE1MID0gb3V0cHV0O1xuICByZXR1cm4gdGFibGU7XG59Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/modules/table_creator.js\n");

/***/ }),

/***/ "./src/modules/tooltips.js":
/*!*********************************!*\
  !*** ./src/modules/tooltips.js ***!
  \*********************************/
/*! exports provided: tooltip, tooltip1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tooltip\", function() { return tooltip; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"tooltip1\", function() { return tooltip1; });\nlet tooltip = d3.select(\"body\")\n\t\t\t\t\t\t\t\t\t\t\t .append(\"div\")\n\t\t\t\t\t\t\t\t\t\t\t .attr(\"class\", \"tooltip\")\n\t\t\t\t\t\t\t\t\t\t\t .style(\"opacity\", 0);\n\nlet tooltip1 = d3.select(\"body\")\n\t\t\t\t\t\t\t\t\t\t\t\t.append(\"div\")\n\t\t\t\t\t\t\t\t\t\t\t\t.attr(\"class\", \"tooltip1\")\n\t\t\t\t\t\t\t\t\t\t\t\t.style(\"opacity\", 0);//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbW9kdWxlcy90b29sdGlwcy5qcy5qcyIsInNvdXJjZXMiOlsid2VicGFjazovLy8uL3NyYy9tb2R1bGVzL3Rvb2x0aXBzLmpzPzc1MDgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGxldCB0b29sdGlwID0gZDMuc2VsZWN0KFwiYm9keVwiKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCAuYXBwZW5kKFwiZGl2XCIpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0IC5hdHRyKFwiY2xhc3NcIiwgXCJ0b29sdGlwXCIpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0IC5zdHlsZShcIm9wYWNpdHlcIiwgMCk7XG5cbmV4cG9ydCBsZXQgdG9vbHRpcDEgPSBkMy5zZWxlY3QoXCJib2R5XCIpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQuYXBwZW5kKFwiZGl2XCIpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQuYXR0cihcImNsYXNzXCIsIFwidG9vbHRpcDFcIilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC5zdHlsZShcIm9wYWNpdHlcIiwgMCk7Il0sIm1hcHBpbmdzIjoiQUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/modules/tooltips.js\n");

/***/ }),

/***/ "./src/modules/utilities.js":
/*!**********************************!*\
  !*** ./src/modules/utilities.js ***!
  \**********************************/
/*! exports provided: plotClearer, searchdic, getParameterByName, printArray, xValue, yValue, xScale, yScale, xMap, yMap, xAxis, yAxis */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"plotClearer\", function() { return plotClearer; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"searchdic\", function() { return searchdic; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"getParameterByName\", function() { return getParameterByName; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"printArray\", function() { return printArray; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"xValue\", function() { return xValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"yValue\", function() { return yValue; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"xScale\", function() { return xScale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"yScale\", function() { return yScale; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"xMap\", function() { return xMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"yMap\", function() { return yMap; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"xAxis\", function() { return xAxis; });\n/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, \"yAxis\", function() { return yAxis; });\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./constants.js */ \"./src/modules/constants.js\");\n\n\nconst plotClearer = {\n  clearTable: () => {\n    document.getElementById(\"demo3\").innerHTML = \"\";\n    d3.select(\"table\").remove();\n  },\n  clearAll: () => {\n    plotClearer.clearTable();\n    document.getElementById(\"predicted_words\").innerHTML = \"\";\n    document.getElementById(\"frequent_words\").innerHTML = \"\";\n    d3.select(\"svg\").remove();\n  }\n};\n\n// AJF: Curious to figure out what is `arri`. Can we rename?\n// used to search a particular substring in the list of requested feature column\n// used to determine whether we should add find to arri, hence the t/f -> f/t\n\nfunction searchdic(arri, find) {\n  for(var i=0;i<arri.length;i++) {\n    if(JSON.stringify(find) === JSON.stringify(arri[i])){\n      return false;\n    }\n  }\n  return true;\n}\n\n// Checks the url query for name=value and extracts the value\n// *************************************************************\n// TODO: This can likely be accomplished using newer browser APIS, e.g.:\n// let queryParams = (new URL(location)).searchParams;\n// Seems like there's generally decent support of above API through caniuse.com\nfunction getParameterByName(name, url) {\n  if (!url) {\n    url = window.location.href;\n  }\n  name = name.replace(/[\\[\\]]/g, \"\\\\$&\");\n  var regex = new RegExp(\"[?&]\" + name + \"(=([^&#]*)|&|#|$)\"),\n  results = regex.exec(url);\n  if (!results) return null;\n  if (!results[2]) return '';\n  return decodeURIComponent(results[2].replace(/\\+/g, \" \"));\n}\n\n// to print all the key values pairs of a point (used to display the summary on the webpage)\nfunction printArray(arr, d) {\n  var x = \"\";\n  for (var i=0; i<arr.length; i++) {\n    x = x + \"<b>\" + arr[i] + \"</b>: \" + d[arr[i]] + \"<br>\"\n  }\n  x = x + d.x + \"<br>\" + d[\"y\"];\n  return x;\n};\n\n// NOTE: I might want to move these axes functions to an axis module\n// The following two functions are getter methods:\n// value accessor - returns the value to encode for a given data object.\n// Type Signature: data Object -> value\nfunction xValue(data) { return data.x };\nfunction yValue(data) { return data[\"y\"] };\n\n// The following two functions map a value to a visual display encoding, such as\n// a pixel position.\n// Type Signature: Value -> display Object\nlet xScale = d3.scale.linear().range([0, _constants_js__WEBPACK_IMPORTED_MODULE_0__[\"width\"]]);\nlet yScale = d3.scale.linear().range([_constants_js__WEBPACK_IMPORTED_MODULE_0__[\"height\"], 0]);\n\n// The following two functions map from data Object to display value (? not sure\n// if value of object)\n// Type Signature: data Object -> display Object (? Might be value)\nfunction xMap(data) { return xScale(xValue(data)) };\nfunction yMap(data) { return yScale(yValue(data)) };\n\n// The following two variables are the X and Y axis objects\nlet xAxis = d3.svg.axis().scale(xScale).orient(\"bottom\");\nlet yAxis = d3.svg.axis().scale(yScale).orient(\"left\");//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9zcmMvbW9kdWxlcy91dGlsaXRpZXMuanMuanMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9zcmMvbW9kdWxlcy91dGlsaXRpZXMuanM/OTc2OSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyB3aWR0aCwgaGVpZ2h0IH0gZnJvbSAnLi9jb25zdGFudHMuanMnO1xuXG5leHBvcnQgY29uc3QgcGxvdENsZWFyZXIgPSB7XG4gIGNsZWFyVGFibGU6ICgpID0+IHtcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcImRlbW8zXCIpLmlubmVySFRNTCA9IFwiXCI7XG4gICAgZDMuc2VsZWN0KFwidGFibGVcIikucmVtb3ZlKCk7XG4gIH0sXG4gIGNsZWFyQWxsOiAoKSA9PiB7XG4gICAgcGxvdENsZWFyZXIuY2xlYXJUYWJsZSgpO1xuICAgIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKFwicHJlZGljdGVkX3dvcmRzXCIpLmlubmVySFRNTCA9IFwiXCI7XG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoXCJmcmVxdWVudF93b3Jkc1wiKS5pbm5lckhUTUwgPSBcIlwiO1xuICAgIGQzLnNlbGVjdChcInN2Z1wiKS5yZW1vdmUoKTtcbiAgfVxufTtcblxuLy8gQUpGOiBDdXJpb3VzIHRvIGZpZ3VyZSBvdXQgd2hhdCBpcyBgYXJyaWAuIENhbiB3ZSByZW5hbWU/XG4vLyB1c2VkIHRvIHNlYXJjaCBhIHBhcnRpY3VsYXIgc3Vic3RyaW5nIGluIHRoZSBsaXN0IG9mIHJlcXVlc3RlZCBmZWF0dXJlIGNvbHVtblxuLy8gdXNlZCB0byBkZXRlcm1pbmUgd2hldGhlciB3ZSBzaG91bGQgYWRkIGZpbmQgdG8gYXJyaSwgaGVuY2UgdGhlIHQvZiAtPiBmL3RcblxuZXhwb3J0IGZ1bmN0aW9uIHNlYXJjaGRpYyhhcnJpLCBmaW5kKSB7XG4gIGZvcih2YXIgaT0wO2k8YXJyaS5sZW5ndGg7aSsrKSB7XG4gICAgaWYoSlNPTi5zdHJpbmdpZnkoZmluZCkgPT09IEpTT04uc3RyaW5naWZ5KGFycmlbaV0pKXtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIENoZWNrcyB0aGUgdXJsIHF1ZXJ5IGZvciBuYW1lPXZhbHVlIGFuZCBleHRyYWN0cyB0aGUgdmFsdWVcbi8vICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcbi8vIFRPRE86IFRoaXMgY2FuIGxpa2VseSBiZSBhY2NvbXBsaXNoZWQgdXNpbmcgbmV3ZXIgYnJvd3NlciBBUElTLCBlLmcuOlxuLy8gbGV0IHF1ZXJ5UGFyYW1zID0gKG5ldyBVUkwobG9jYXRpb24pKS5zZWFyY2hQYXJhbXM7XG4vLyBTZWVtcyBsaWtlIHRoZXJlJ3MgZ2VuZXJhbGx5IGRlY2VudCBzdXBwb3J0IG9mIGFib3ZlIEFQSSB0aHJvdWdoIGNhbml1c2UuY29tXG5leHBvcnQgZnVuY3Rpb24gZ2V0UGFyYW1ldGVyQnlOYW1lKG5hbWUsIHVybCkge1xuICBpZiAoIXVybCkge1xuICAgIHVybCA9IHdpbmRvdy5sb2NhdGlvbi5ocmVmO1xuICB9XG4gIG5hbWUgPSBuYW1lLnJlcGxhY2UoL1tcXFtcXF1dL2csIFwiXFxcXCQmXCIpO1xuICB2YXIgcmVnZXggPSBuZXcgUmVnRXhwKFwiWz8mXVwiICsgbmFtZSArIFwiKD0oW14mI10qKXwmfCN8JClcIiksXG4gIHJlc3VsdHMgPSByZWdleC5leGVjKHVybCk7XG4gIGlmICghcmVzdWx0cykgcmV0dXJuIG51bGw7XG4gIGlmICghcmVzdWx0c1syXSkgcmV0dXJuICcnO1xuICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KHJlc3VsdHNbMl0ucmVwbGFjZSgvXFwrL2csIFwiIFwiKSk7XG59XG5cbi8vIHRvIHByaW50IGFsbCB0aGUga2V5IHZhbHVlcyBwYWlycyBvZiBhIHBvaW50ICh1c2VkIHRvIGRpc3BsYXkgdGhlIHN1bW1hcnkgb24gdGhlIHdlYnBhZ2UpXG5leHBvcnQgZnVuY3Rpb24gcHJpbnRBcnJheShhcnIsIGQpIHtcbiAgdmFyIHggPSBcIlwiO1xuICBmb3IgKHZhciBpPTA7IGk8YXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgeCA9IHggKyBcIjxiPlwiICsgYXJyW2ldICsgXCI8L2I+OiBcIiArIGRbYXJyW2ldXSArIFwiPGJyPlwiXG4gIH1cbiAgeCA9IHggKyBkLnggKyBcIjxicj5cIiArIGRbXCJ5XCJdO1xuICByZXR1cm4geDtcbn07XG5cbi8vIE5PVEU6IEkgbWlnaHQgd2FudCB0byBtb3ZlIHRoZXNlIGF4ZXMgZnVuY3Rpb25zIHRvIGFuIGF4aXMgbW9kdWxlXG4vLyBUaGUgZm9sbG93aW5nIHR3byBmdW5jdGlvbnMgYXJlIGdldHRlciBtZXRob2RzOlxuLy8gdmFsdWUgYWNjZXNzb3IgLSByZXR1cm5zIHRoZSB2YWx1ZSB0byBlbmNvZGUgZm9yIGEgZ2l2ZW4gZGF0YSBvYmplY3QuXG4vLyBUeXBlIFNpZ25hdHVyZTogZGF0YSBPYmplY3QgLT4gdmFsdWVcbmV4cG9ydCBmdW5jdGlvbiB4VmFsdWUoZGF0YSkgeyByZXR1cm4gZGF0YS54IH07XG5leHBvcnQgZnVuY3Rpb24geVZhbHVlKGRhdGEpIHsgcmV0dXJuIGRhdGFbXCJ5XCJdIH07XG5cbi8vIFRoZSBmb2xsb3dpbmcgdHdvIGZ1bmN0aW9ucyBtYXAgYSB2YWx1ZSB0byBhIHZpc3VhbCBkaXNwbGF5IGVuY29kaW5nLCBzdWNoIGFzXG4vLyBhIHBpeGVsIHBvc2l0aW9uLlxuLy8gVHlwZSBTaWduYXR1cmU6IFZhbHVlIC0+IGRpc3BsYXkgT2JqZWN0XG5leHBvcnQgbGV0IHhTY2FsZSA9IGQzLnNjYWxlLmxpbmVhcigpLnJhbmdlKFswLCB3aWR0aF0pO1xuZXhwb3J0IGxldCB5U2NhbGUgPSBkMy5zY2FsZS5saW5lYXIoKS5yYW5nZShbaGVpZ2h0LCAwXSk7XG5cbi8vIFRoZSBmb2xsb3dpbmcgdHdvIGZ1bmN0aW9ucyBtYXAgZnJvbSBkYXRhIE9iamVjdCB0byBkaXNwbGF5IHZhbHVlICg/IG5vdCBzdXJlXG4vLyBpZiB2YWx1ZSBvZiBvYmplY3QpXG4vLyBUeXBlIFNpZ25hdHVyZTogZGF0YSBPYmplY3QgLT4gZGlzcGxheSBPYmplY3QgKD8gTWlnaHQgYmUgdmFsdWUpXG5leHBvcnQgZnVuY3Rpb24geE1hcChkYXRhKSB7IHJldHVybiB4U2NhbGUoeFZhbHVlKGRhdGEpKSB9O1xuZXhwb3J0IGZ1bmN0aW9uIHlNYXAoZGF0YSkgeyByZXR1cm4geVNjYWxlKHlWYWx1ZShkYXRhKSkgfTtcblxuLy8gVGhlIGZvbGxvd2luZyB0d28gdmFyaWFibGVzIGFyZSB0aGUgWCBhbmQgWSBheGlzIG9iamVjdHNcbmV4cG9ydCBsZXQgeEF4aXMgPSBkMy5zdmcuYXhpcygpLnNjYWxlKHhTY2FsZSkub3JpZW50KFwiYm90dG9tXCIpO1xuZXhwb3J0IGxldCB5QXhpcyA9IGQzLnN2Zy5heGlzKCkuc2NhbGUoeVNjYWxlKS5vcmllbnQoXCJsZWZ0XCIpOyJdLCJtYXBwaW5ncyI6IkFBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/modules/utilities.js\n");

/***/ })

/******/ });